[
{
	"uri": "http://Khoadora.github.io/2-build-a-chatbot/2.1-create-bot-and-configure/",
	"title": "Create bot and Configure",
	"tags": [],
	"description": "",
	"content": "In this step, we will learn how to create and configure a bot named \u0026ldquo;FriedChickenFriend\u0026rdquo; on Amazon Lex.\nTask 1: Configure bot settings Go to Amazon lex management console\nClick Create bot. In Creation method, click Traditional - Create a blank bot. In Bot configuration, enter Bot name is FriedChickenFriend. In IAM permissions, click Create a role with basic Amazon Lex permissions..\nIn Children’s Online Privacy Protection Act (COPPA), click No.\nClick Next. Task 2: Add languages In Select language, select English (US). In Voice interaction, select Matthew. In Intent classification confidence score threshold, enter 0.04. Click Done. Task 3: Check Back on the Amazon lex management screen, we see that the FriedChickenFriend bot has been created. "
},
{
	"uri": "http://Khoadora.github.io/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.1.-create-intent-greeting/",
	"title": "Create intent Greeting",
	"tags": [],
	"description": "",
	"content": " At Intent name enter Greeting. At Sample utterances enter in Add utterance is Hello, Hi, Hey FriedChickenFriend. At Closing response enter in Messege is Hello, Welcome to FriedChickenFriend. Would you like to order a Fried Chicken ? and enter in Variations is Hello ! Would you like to order Friend Chicken for lunch ?, Hi there !, I'm a FriedChickenFriend bot. Would you like to order a Fried Chicken ?. Click Save intent and Build.\nFirst build can take several minutes.\nAfter Build, click Test and enter the utterances to test as below. "
},
{
	"uri": "http://Khoadora.github.io/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Goals of the Workshops: After completing this workshop, you will learn how to:\nCreate a chatbot with multiple intents and Lambda handlers, add response tags. Create a standalone website for your existing Amazon Lex bot or embed it into your existing website. Apply the chatbot to Slack application to facilitate communication and work. Workshop architecture: This architecture describes a chatbot system that integrates Slack and a website with AWS services. Users interact via Slack or the website, requests are routed to Amazon API Gateway, then to Amazon Lex for natural language processing. Lambda executes the application logic, while Amazon Polly can generate voice responses. IAM Roles ensure access between services, and CloudWatch monitors the system and logs. Workshop Prerequisites: Your account must have the ability to create new IAM roles and scope other IAM permissions. If you already have an AWS account and have IAM Administrator access, you can skip this page completely and proceed to the next step.\nIf you don’t already have an AWS account with Administrator access then create one here now by hitting the Create an AWS Account button\nOnce you have an AWS account, ensure you are following the remaining workshop steps as an IAM user with administrator access to the AWS account - open this link and then follow the instructions below: Create a new IAM user to use for the workshop Select Users in the left command list, click the Add User button, enter User name and click the Next button. In Permissions options, attach the AdministratorAccess IAM Policy by selecting it from the list of available permission policies, and then click the Next button. Review your selections, and if you are happy with them then click on the Create user button. If you would like to make some changes then hit the Previous button. The final result is as follows: Note: The above is referenced and imaged from Create an AWS Account Contents: Build a ChatBot to order Fried Chicken Validate Slot data with Lambda Integrate ChatBot into a Web Page Add Response Cards Slack Integration Clean up "
},
{
	"uri": "http://Khoadora.github.io/3-validate-slot-data-with-lambda/3.1-rebuilding-a-simpler-chatbot/",
	"title": "Rebuilding a simpler chatbot",
	"tags": [],
	"description": "",
	"content": " Here we will rebuild a simple fried chicken ordering chatbot that is simpler than the old chatbot (in part 2) without side dishes or drinks to simplify the Lambda implementation. Note that you can still confirm to add side dishes or drinks to enhance this project. Here is a summary table of all the Intents and Slot types we will create in this section: Content:\nCreate bot and Slot types. Create Intent. 3.1.1. Create bot and Slot types. Task 1: Create bot Step 1: Configure bot settings Go to Amazon lex management console\nClick Create bot. In Creation method, click Traditional - Create a blank bot. In Bot configuration, enter Bot name is FriedChickenFriend_Simple. In IAM permissions, click Create a role with basic Amazon Lex permissions..\nIn Children’s Online Privacy Protection Act (COPPA), click No.\nClick Next. Step 2: Add languages In Select language, select English (US). In Voice interaction, select Matthew. In Intent classification confidence score threshold, enter 0.04. Click Done. Step 3: Check Back on the Amazon lex management screen, we see that the FriedChickenFriend_Simple bot has been created. Task 2: Create Slot types Step 1: Create Slot type FriedChickenSizes Click Slot types. Click Add slot type - Add blank slot type. Enter name slot type is FriedChickenSizes. At Slot value resolution, select Expand values (default) At Slot type values, enter values are Small, Medium, Large, Family Size. Enter Save Slot type Step 2: Create Slot type FriedChicken_branch Back to Slot types Click Slot types. Click Add slot type - Add blank slot type. Enter name slot type is FriedChicken_branch. At Slot value resolution, select Expand values (default) At Slot type values, enter values are KFC, Jollipee, Texas. Enter Save Slot type Step 3: Create Slot type FriedChicken_Types Back to Slot types Click Slot types. Click Add slot type - Add blank slot type. Enter name slot type is FriedChicken_Types. At Slot value resolution, select Expand values (default) At Slot type values, enter values are Original Recipe, Extra Crispy, Hot \u0026amp; Spicy, Classic, Spicy, Sweet Chili, Smoky BBQ, Cajun Spice, Honey Butter. Enter Save Slot type 3.1.2. Create intents OrderFriedChicken At Intent name enter OrderFriedChicken. Scroll down Slots - Add slot. Here, we will add 3 slot types created in step 3.1.1 with the same method as part 2. The Slot names are FriedChickenSizes, FriedChicken_branch and FriedChicken_Types respectively. At Sample utterances enter in Add utterance as image below. where {FriedChickenSizes}, {FriedChicken_Types} and {FriedChicken_branch} will be the value the user chooses from Slots.\nScroll down Confirmation. In the confirmation prompt, write Would you like me to order your {FriedChickenSizes} {FriedChicken_Types} from {FriedChicken_branch} ?. { Where {FriedChickenSizes}, {FriedChicken_Types} and {FriedChicken_branch} will be the value the user chooses from Slots.\nIn case the user answers No, I will set the Decline response for the bot to respond as Stay hungry, my friend. Scroll down Fulfillment. On successful fulfillment as I've ordered your {FriedChickenSizes} {FriedChicken_Types} from {FriedChicken_branch}. In case of failure as Oop, Something went wrong, please try again. Click Save intent and Build After Build, click Test and enter the messages to test as below. When I order Sweet Chili from KFC, the problem here is that the KFC branch doesn\u0026rsquo;t have Sweet Chili, the Sweet Chili comes from the Jollipee branch, so I\u0026rsquo;ll say No. But now we need a way to validate that user input, so if the user tries to order a Sweet Chili from KFC, we won\u0026rsquo;t allow the bot to do so and prompt the user to provide the proper data. To do that we\u0026rsquo;ll use Lambda.\n"
},
{
	"uri": "http://Khoadora.github.io/2-build-a-chatbot/",
	"title": "Build a ChatBot to order Fried Chicken",
	"tags": [],
	"description": "",
	"content": " Please create your bot using the English (US) language. This Workshop uses the Context Carryover feature of Amazon Lex, which is only available in that language.\nThis demo bot will create a simple fried chicken ordering chatbot that can provide some basic ordering functionality, such as selecting size, branch and type of each branch, side dishes and drinks. This section will show you how to initialize and configure the bot, build intents and slot types for each intent.\nHere is a summary table of all the Intents and Slot types we will create in this section: Content Create bot and Configure Create Intent and Slot types "
},
{
	"uri": "http://Khoadora.github.io/2-build-a-chatbot/2.2-create-intent-and-slot-types/",
	"title": "Create Intent and Slot types",
	"tags": [],
	"description": "",
	"content": "In this step, we will create intents and slot types, there are a total of 8 Intents and 6 Slot types in all. The intents and slot types are described below. Content Create intent greeting Create intent FriedChickenOrder and Slot types FriedChickenSize Create intent KFC_branch and Slot types KFC_types Create intent Jollipee_branch and Slot types Jollipee_types Create intent Texas_branch and Slot types Texas_types Create intent SideOrder and Slot types Side_types Create intent DrinkOrder and Slot types Drink_types Configure intent FallbackIntent "
},
{
	"uri": "http://Khoadora.github.io/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.2.-create-intent-friedchickenorder-and-slot-type-friedchickensize/",
	"title": "Create intent FriedChickenOrder and Slot types FriedChickenSize",
	"tags": [],
	"description": "",
	"content": "Task 1: Create intent FriedChickenOrder At Intent name enter FriedChickenOrder. At Sample utterances enter in Add utterance is I'd like to order Fried Chicken, I want to order Fried Chicken, Fried Chicken. At Initial response enter message is Okey, I can help you order a Fried Chicken. Click *Save intent. Task 2: Create Slot types FriedChickenSize Back to intents list. Click Slot types. Click Add slot type - Add blank slot type. Enter name slot type is FriedChickenSizes. At Slot value resolution, select Expand values (default) At Slot type values, enter values are Small, Medium, Large, Family Size. Enter Save Slot type Task 3: Add Slot types FriedChickenSize to the intent FriedChickenOrder Next, Back to intents list, select intent name FriedChickenOrder. Scroll down Slots - Add slot. At slot type, select FriedChickenSizes At Name, enter FriedChickenSize At Prompts, enter Which size fried chicken would you like (small, medium, larger, family size) ?. Click Add. * Scroll down Closing response. In the message, I\u0026rsquo;ll write Okay, You'd like a {FriedChickenSizes} fried chicken.. Then, I will continue to ask Where would you like to order from (KFC, Jollibee orTexas) ?. where {FriedChickenSizes} will be the value the user chooses from Slots.\nClick Save intent and Build After Build, click Test and enter the messages to test as below. "
},
{
	"uri": "http://Khoadora.github.io/3-validate-slot-data-with-lambda/3.2-use-a-lambda-functions-for-chatbot/",
	"title": "Use a Lambda functions for chatbot",
	"tags": [],
	"description": "",
	"content": " Here we will add a Lambda function to the FriedChickenFriend_Simple chatbot to validate user input. I put the code Lambda functions at the bottom of the page, you can scroll down to the bottom to see it or follow the link for reference: Code Lambda function Content:\nCreate Lambda function. Add Lambda function in chatbot. Task 1: Create Lambda function Go to AWS Lambda\nClick Create a function. Click Author from scratch.\nFunction name is FriedChickenOrder.\nRuntime select Python 3.12.\nArchitecture select x86_64.\nClick Create function. Below is the image of the result after initialization: Next we will code the Lambda function for our chatbot. I have prepared it and now I will state the function of each code segment:\nImporting Dependencies The json module is imported. This module is typically used to handle JSON data, such as parsing or serializing JSON objects. import json Defining Variables These variables define available options for sizes, fried chicken branches (KFC, Jollibee, Texas), and the respective chicken types for each branch.\nFriedChickenSizes lists the available size options. FriedChicken_branch lists the available fast-food chains. KFC_types, Jollipee_types, and Texas_types store the different chicken types specific to each branch. friedChickenSizes = [\u0026#39;small\u0026#39;, \u0026#39;medium\u0026#39;, \u0026#39;large\u0026#39;, \u0026#39;family size\u0026#39;] friedChicken_branch = [\u0026#39;kfc\u0026#39;, \u0026#39;jollipee\u0026#39;, \u0026#39;texas\u0026#39;] kfc_types = [\u0026#39;original\u0026#39;, \u0026#39;extra crispy\u0026#39;, \u0026#39;hot \u0026amp; spicy\u0026#39;] jollipee_types = [\u0026#39;classic\u0026#39;, \u0026#39;spicy\u0026#39;, \u0026#39;sweet chili\u0026#39;] texas_types = [\u0026#39;smoky bbq\u0026#39;, \u0026#39;cajun spice\u0026#39;, \u0026#39;honey butter\u0026#39;] Defining the validate_order Function This function validates the input received from the user through a chatbot. It checks if the provided values for size, branch, and type of fried chicken are valid. def validate_order(slots): 3.1 Validation of FriedChickenSizes\nFirst check: If the FriedChickenSizes slot is empty, it marks this slot as invalid and returns an appropriate response to prompt the user to select a size. Second check: It then verifies whether the selected size exists in the FriedChickenSizes list. If it doesn’t, it prompts the user with a message asking to select one of the valid options. def validate_order(slots): # Validate FriedChickenSizes if \u0026#39;FriedChickenSizes\u0026#39; not in slots or not slots[\u0026#39;FriedChickenSizes\u0026#39;]: print(\u0026#39;Validating FriedChickenSizes Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChickenSizes\u0026#39; } if slots[\u0026#39;FriedChickenSizes\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in friedChickenSizes: print(\u0026#39;Invalid FriedChickenSizes\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChickenSizes\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a {} burger size.\u0026#39;.format(\u0026#34;, \u0026#34;.join(friedChickenSizes)) } 3.2 Validation of FriedChicken_branch and FriedChickenType\nFirst check: Similar to the previous check, this part checks if the FriedChicken_branch slot is provided. Second check: It then validates whether the provided branch (e.g., KFC, Jollibee) exists in the FriedChicken_branch list. If it\u0026rsquo;s invalid, a prompt is returned to select from valid branches. First check: This part checks if the FriedChicken_Types slot is provided. # Validate FriedChicken_branch if \u0026#39;FriedChicken_branch\u0026#39; not in slots or not slots[\u0026#39;FriedChicken_branch\u0026#39;]: print(\u0026#39;Validating FriedChicken_branch Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_branch\u0026#39; } if slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in friedChicken_branch: print(\u0026#39;Invalid FriedChicken_branch\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_branch\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select from {} burger franchises.\u0026#39;.format(\u0026#34;, \u0026#34;.join(friedChicken_branch)) } # Validate FriedChicken_Types if \u0026#39;FriedChicken_Types\u0026#39; not in slots or not slots[\u0026#39;FriedChicken_Types\u0026#39;]: print(\u0026#39;Validating FriedChicken_Types Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39; } 3.3 Validation of FriedChicken_Types Based on Branch and Valid Order Case\nThis section ensures that the user’s selected FriedChickenType is valid for the specific branch they chose (KFC, Jollibee, Texas). If a type is invalid, the chatbot prompts the user to choose a valid option for the selected branch. If all the above checks pass, the function returns {\u0026lsquo;isValid\u0026rsquo;: True} indicating the order is valid. # Validate FriedChicken_Types for FriedChicken_branch branch_value = slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() type_value = slots[\u0026#39;FriedChicken_Types\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() if branch_value == \u0026#39;kfc\u0026#39;: if type_value not in kfc_types: print(\u0026#39;Invalid FriedChicken_Types for KFC\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a KFC type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(kfc_types)) } elif branch_value == \u0026#39;jollipee\u0026#39;: if type_value not in jollipee_types: print(\u0026#39;Invalid FriedChicken_Types for Jollipee\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a Jollipee type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(jollipee_types)) } elif branch_value == \u0026#39;texas\u0026#39;: if type_value not in texas_types: print(\u0026#39;Invalid FriedChicken_Types for Texas\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a Texas type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(texas_types)) } # Valid Order return {\u0026#39;isValid\u0026#39;: True} Defining the lambda_handler Function The lambda_handler function handles incoming events (from a chatbot, for example). It receives two arguments:\nevent: The event details, including the slots that contain the user`s order information. context: The runtime information for the Lambda function (not used here). def lambda_handler(event, context): print(event) 4.1 Extracting Information from Event and validating the Order\nThe bot`s name, slots, and intent name are extracted from the event object. The validate_order function is called to validate the user`s input (contained in slots). def lambda_handler(event, context): print(event) bot = event[\u0026#39;bot\u0026#39;][\u0026#39;name\u0026#39;] slots = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;slots\u0026#39;] intent = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;name\u0026#39;] order_validation_result = validate_order(slots) 4.2 Handling the Response for DialogCodeHook If the source of invocation is DialogCodeHook, meaning the chatbot is still gathering information, it either:\nPrompts the user to correct an invalid slot. Delegates control to the next step if everything is valid. #Handling the Response for DialogCodeHook if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;DialogCodeHook\u0026#39;: if not order_validation_result[\u0026#39;isValid\u0026#39;]: if \u0026#39;message\u0026#39; in order_validation_result: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;slotToElicit\u0026#34;: order_validation_result[\u0026#39;invalidSlot\u0026#39;], \u0026#34;type\u0026#34;: \u0026#34;ElicitSlot\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;PlainText\u0026#34;, \u0026#34;content\u0026#34;: order_validation_result[\u0026#39;message\u0026#39;] } ] } else: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;slotToElicit\u0026#34;: order_validation_result[\u0026#39;invalidSlot\u0026#39;], \u0026#34;type\u0026#34;: \u0026#34;ElicitSlot\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots } } } else: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Delegate\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#39;name\u0026#39;: intent, \u0026#39;slots\u0026#39;: slots } } } 4.3 Handling FulfillmentCodeHook\nIf the source of invocation is FulfillmentCodeHook, it closes the interaction and confirms that the order has been placed. #Handling FulfillmentCodeHook if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;FulfillmentCodeHook\u0026#39;: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Close\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots, \u0026#34;state\u0026#34;: \u0026#34;Fulfilled\u0026#34; } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;PlainText\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;I\u0026#39;ve placed your order.\u0026#34; } ] } Returning the Response Finally, the response is printed for debugging purposes and returned to the caller (chatbot or user). print(response) return response After adding the code to the Lambda function, enter Deploy to build. Task 2: Add Lambda function in chatbot Go back to the FriedChickenFriend_Sample chatbot. Select the OrderFriedChicken intent. Scroll down to Code hooks, select Use a Lambda function for initialization and validation. Scroll up to Confirmation, select Advanced options. Scroll down to Dialog code hook, select Invoke Lambda function, make sure Active mode is turned on. Select Update options. Scroll down to Fulfillment, select Advanced options. Select Use a Lambda function for fulfillment. Select Update options. Enter Build and Test. Select Setting in chatbot. In Source select function FriedChickenOrder. Click Save. Next I will test the chatbot with some messages as shown below. Looking at the Summary, the input values ​​that I texted are medium, KFC, original have been added to the Elicitation column corresponding to each slot. When I selected smoky bbq from KFC, the bot noticed something was wrong so it rejected and asked me to select again, that is the application of the Lambda function. When I replied Yes, the bot responded with I've placed your order , which was different from the message that was set in Fullfilment initially. I did this so that I could see that the processing was done by Lambda.\nThe full code for the Lambda function: import json friedChickenSizes = [\u0026#39;small\u0026#39;, \u0026#39;medium\u0026#39;, \u0026#39;large\u0026#39;, \u0026#39;family size\u0026#39;] friedChicken_branch = [\u0026#39;kfc\u0026#39;, \u0026#39;jollipee\u0026#39;, \u0026#39;texas\u0026#39;] kfc_types = [\u0026#39;original\u0026#39;, \u0026#39;extra crispy\u0026#39;, \u0026#39;hot \u0026amp; spicy\u0026#39;] jollipee_types = [\u0026#39;classic\u0026#39;, \u0026#39;spicy\u0026#39;, \u0026#39;sweet chili\u0026#39;] texas_types = [\u0026#39;smoky bbq\u0026#39;, \u0026#39;cajun spice\u0026#39;, \u0026#39;honey butter\u0026#39;] def validate_order(slots): # Validate FriedChickenSizes if \u0026#39;FriedChickenSizes\u0026#39; not in slots or not slots[\u0026#39;FriedChickenSizes\u0026#39;]: print(\u0026#39;Validating FriedChickenSizes Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChickenSizes\u0026#39; } if slots[\u0026#39;FriedChickenSizes\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in friedChickenSizes: print(\u0026#39;Invalid FriedChickenSizes\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChickenSizes\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a {} burger size.\u0026#39;.format(\u0026#34;, \u0026#34;.join(friedChickenSizes)) } # Validate FriedChicken_branch if \u0026#39;FriedChicken_branch\u0026#39; not in slots or not slots[\u0026#39;FriedChicken_branch\u0026#39;]: print(\u0026#39;Validating FriedChicken_branch Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_branch\u0026#39; } if slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in friedChicken_branch: print(\u0026#39;Invalid FriedChicken_branch\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_branch\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select from {} burger franchises.\u0026#39;.format(\u0026#34;, \u0026#34;.join(friedChicken_branch)) } # Validate FriedChicken_Types if \u0026#39;FriedChicken_Types\u0026#39; not in slots or not slots[\u0026#39;FriedChicken_Types\u0026#39;]: print(\u0026#39;Validating FriedChicken_Types Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39; } # Validate FriedChicken_Types for FriedChicken_branch branch_value = slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() type_value = slots[\u0026#39;FriedChicken_Types\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() if branch_value == \u0026#39;kfc\u0026#39;: if type_value not in kfc_types: print(\u0026#39;Invalid FriedChicken_Types for KFC\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a KFC type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(kfc_types)) } elif branch_value == \u0026#39;jollipee\u0026#39;: if type_value not in jollipee_types: print(\u0026#39;Invalid FriedChicken_Types for Jollipee\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a Jollipee type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(jollipee_types)) } elif branch_value == \u0026#39;texas\u0026#39;: if type_value not in texas_types: print(\u0026#39;Invalid FriedChicken_Types for Texas\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a Texas type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(texas_types)) } # Valid Order return {\u0026#39;isValid\u0026#39;: True} def lambda_handler(event, context): print(event) bot = event[\u0026#39;bot\u0026#39;][\u0026#39;name\u0026#39;] slots = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;slots\u0026#39;] intent = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;name\u0026#39;] order_validation_result = validate_order(slots) if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;DialogCodeHook\u0026#39;: if not order_validation_result[\u0026#39;isValid\u0026#39;]: if \u0026#39;message\u0026#39; in order_validation_result: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;slotToElicit\u0026#34;: order_validation_result[\u0026#39;invalidSlot\u0026#39;], \u0026#34;type\u0026#34;: \u0026#34;ElicitSlot\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;PlainText\u0026#34;, \u0026#34;content\u0026#34;: order_validation_result[\u0026#39;message\u0026#39;] } ] } else: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;slotToElicit\u0026#34;: order_validation_result[\u0026#39;invalidSlot\u0026#39;], \u0026#34;type\u0026#34;: \u0026#34;ElicitSlot\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots } } } else: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Delegate\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#39;name\u0026#39;: intent, \u0026#39;slots\u0026#39;: slots } } } if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;FulfillmentCodeHook\u0026#39;: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Close\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots, \u0026#34;state\u0026#34;: \u0026#34;Fulfilled\u0026#34; } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;PlainText\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;I\u0026#39;ve placed your order.\u0026#34; } ] } print(response) return response "
},
{
	"uri": "http://Khoadora.github.io/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.3.-create-intent-kfc_branch-and-slot-types-kfc_types/",
	"title": "Create intent KFC_branch and Slot types KFC_types",
	"tags": [],
	"description": "",
	"content": "Task 1: Create intent KFC_branch At Intent name enter KFC_branch. At Sample utterances enter in Add utterance is KFC. At Initial response enter message is Okay, you would like KFC fried chicken Click Save intent and back to intents list Task 2: Create Slot types KFC_types Back to intents list. Click Slot types. Click Add slot type - Add blank slot type. Enter name slot type is KFC_types. At Slot value resolution, select Expand values (default) At Slot type values, enter values are Original Recipe, Extra Crispy, Hot \u0026amp; Spicy. Enter Save Slot type Task 3: Add Slot types KFC_types to the intent KFC_branch Next, Back to intents list, select intent name KFC_branch.\nScroll down Slots - Add slot.\nAt slot type, select KFC_types\nAt Name, enter KFC_types\nAt Prompts, enter Which KFC fried chicken would you like(Original Recipe, Extra Crispy, Hot \u0026amp; Spicy) ?.\nClick Add. Scroll down Confirmation. In the confirmation prompt, I\u0026rsquo;ll write Nice ! Would you like me to order your {KFC_types} ?. Where {KFC_types} will be the value the user chooses from Slots.\nIn case the user answers No, I will set the Decline response for the bot to respond as Bummer! Stay hungry, my friend. *\nScroll down Fulfillment. I will notify user of status when completed at On successful fulfillment as Okay, your order is on its way. Would you like to order another fried chicken, a side, or a drink ?\nIn case of failure as Oh no! Something went wrong. Please try again. *\nClick Save intent and Build\nAfter Build, click Test and enter the messages to test as below. "
},
{
	"uri": "http://Khoadora.github.io/3-validate-slot-data-with-lambda/",
	"title": "Validate Slot data with Lambda",
	"tags": [],
	"description": "",
	"content": " In this part we will validate the Slot data with Lambda so that when the user selects the wrong value, the chatbot will ask us to select the correct value again. I noticed that the chatbot in part 2 has a comprehensive menu (including side dishes and drinks), however, to simplify the coding of the Lambda function for you and me, I will rebuild a simpler chatbot with the purpose of ordering fried chicken in part 3.1. Content Rebuilding a simpler chatbot Use a Lambda functions for chatbot "
},
{
	"uri": "http://Khoadora.github.io/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.4.-create-intent-jollipee_branch-and-slot-types-jollipee_types/",
	"title": "Create intent Jollipee_branch and Slot types Jollipee_types",
	"tags": [],
	"description": "",
	"content": "Task 1: Create intent Jollipee_branch At Intent name enter Jollipee_branch. At Sample utterances enter in Add utterance is Jollipee. At Initial response enter message is Okey, You would like Jollipee fried chicken. Click Save intent and back to intents list Task 2: Create Slot types Jollipee_types for intent Jollipee_branch Click Slot types. Click Add slot type - Add blank slot type. Enter name slot type is Jollipee_types. At Slot value resolution, select Expand values (default) At Slot type values, enter values are Classic, Spicy, Sweet Chili. Enter Save Slot type Task 3: Add Slot types Jollipee_types to the intent Jollipee_branch Next, Back to intents list, select intent name Jollipee_branch. Scroll down Slots - Add slot. At slot type, select Jollipee_types At Name, enter Jollipee_types At Prompts, enter Which Jollipee fried chicken would you like(Classic, Spicy, Sweet Chili) ?. Click Add. Scroll down Confirmation. In the confirmation prompt, I\u0026rsquo;ll write Nice ! Would you like me to order your {Jollipee_types} ?. In case the user answers No, I will set the Decline response for the bot to respond as Bummer! Stay hungry, my friend. * Scroll down Fulfillment. I will notify user of status when completed at On successful fulfillment as Okay, your order is on its way. Would you like to order another fried chicken, a side, or a drink ? In case of failure as Oh no! Something went wrong. Please try again. Click Save intent and Build. After Build, click Test and enter the messages to test as below. "
},
{
	"uri": "http://Khoadora.github.io/4-integrate-chatbot-into-a-web-page/",
	"title": "Integrate ChatBot into a Web Page",
	"tags": [],
	"description": "",
	"content": " Here we will Integrate FriedChickenFriend_Simple chatbot into a web page. I put the code of my web page at the bottom of the page, you can scroll down to the bottom to see it or follow the link for reference: Code Web page Content:\nAdd Amazon lex into Kommunicate app. Add chatbot into web page . Task 1: Add Amazon lex into Kommunicate app Go to Komunicate web Click Try for free and log in with your student email or work email to use it for free. This is the app interface after logging in, select Bot Integration. Click integration bot at Amazon lex. After selecting, the app will have an interface as shown below, I will show you how to get Access key ID and Secret access key. Go to AWS IAM console Click User groups - Create group. Enter User group name as LexAdmins. In Add users to the group, select an existing user. In Attach permissions policies, search for lex and select AmazonLexFullAccess. Click Create user group. Go back to IAM console, select User - Click the user name created earlier, my user name is khoa. Select Security credentials, scroll down to Access keys and select Create access key. Regarding Use case*, select Other. Select Next. In Description tag value, enter access Konmunicate. Select Create access key. Once done, you will see Access key and Secret access key displayed, copy it to note and enter Done. Go back to the Kommunicate app, copy the Access key ID and Secret access key from the note and fill them in. In Region, select US East. In Bot name in Lex platform, select FriedChickenFriend_Simple. In Bot alias, select TestBotAlias. In Default bot language, select English (US). Enter Save and procced. Use the bot name and avatar as desired, here I leave it as default. Select Disable this feature, then enter Finish bot setup. Once done, enter Try out your new bot, FriedChickenFriend_Simple. The app will take us to another website, here we can see our FriedChickenFriend_Simple bot. I will test some messages as shown below. Task 2: Add chatbot into web page Below is the website interface that I have created, you can get the website code through the link: Now, go back to the Kommunicate app, select Setting. Select Install, copy the code to put into the html file. Put the copied code into the head tag and restart the website. We can see the chatbot icon has been added to the website. Now I will test some messages to check and complete this part. The entire code of the website, run by html file: \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Fried Chicken Menu\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;img/favicon.ico\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; /* Reset margin and padding */ * { margin: 0; padding: 0; box-sizing: border-box; } /* Body settings */ body { font-family: \u0026#39;Arial\u0026#39;, sans-serif; background-color: #f8f9fa; color: #343a40; display: flex; flex-direction: column; height: 100vh; } /* Header settings */ header { background-color: #d62828; color: white; padding: 20px 0; text-align: center; flex: 0 1 15%; /* Occupy 15% of the screen height */ } header h1 { font-size: 2.5rem; } /* Navigation menu */ nav { display: flex; justify-content: center; background-color: #003049; padding: 10px 0; margin-bottom: 20px; } nav ul { list-style: none; display: flex; gap: 20px; } nav ul li { color: white; font-size: 1.2rem; cursor: pointer; transition: color 0.3s; } nav ul li:hover { color: #ffc300; } /* Main content */ main { flex: 1; /* Occupy remaining space */ display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; } /* Section for each menu */ section { background-color: white; border-radius: 10px; padding: 20px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); width: 80%; max-width: 800px; margin-bottom: 20px; } section h2, section h3 { color: #003049; margin-bottom: 15px; } /* Horizontal menu styling */ section ul { list-style: none; padding-left: 0; display: flex; justify-content: space-around; } section ul li { display: flex; flex-direction: column; align-items: center; background-color: #f1f1f1; margin: 10px; padding: 10px; border-radius: 8px; transition: background-color 0.3s ease; text-align: center; } section ul li:hover { background-color: #f7c59f; } /* Footer settings */ footer { background-color: #003049; color: white; text-align: center; padding: 10px 0; flex: 0 1 10%; /* Occupy 10% of the screen height */ } footer a { color: #ffc300; text-decoration: none; } footer a:hover { text-decoration: underline; } \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; (function(d, m){ var kommunicateSettings = {\u0026#34;appId\u0026#34;:\u0026#34;35a6190fee5ad6aba7d62941d9d0c952d\u0026#34;,\u0026#34;popupWidget\u0026#34;:true,\u0026#34;automaticChatOpenOnNavigation\u0026#34;:true}; var s = document.createElement(\u0026#34;script\u0026#34;); s.type = \u0026#34;text/javascript\u0026#34;; s.async = true; s.src = \u0026#34;https://widget.kommunicate.io/v2/kommunicate.app\u0026#34;; var h = document.getElementsByTagName(\u0026#34;head\u0026#34;)[0]; h.appendChild(s); window.kommunicate = m; m._globals = kommunicateSettings; })(document, window.kommunicate || {}); /* NOTE : Use web server to view HTML files as real-time update will not work if you directly open the HTML file in the browser. */ \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Fried Chicken Menu\u0026lt;/h1\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;!-- Navigation menu --\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Home\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Menu\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Contact\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;About\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;main\u0026gt; \u0026lt;!-- KFC Menu --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h2\u0026gt;KFC Fried Chicken\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Original Recipe\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Extra Crispy\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Hot \u0026amp; Spicy\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- Jollibee Menu --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h2\u0026gt;Jollibee Fried Chicken\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Classic\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Spicy\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Sweet Chili\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- Texas Menu --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h2\u0026gt;Texas Fried Chicken\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Smoky BBQ\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Cajun Spice\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Honey Butter\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- Chicken Sizes --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h3\u0026gt;Chicken Sizes (# pieces)\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Small\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Medium\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Large\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Family Size\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;p\u0026gt;\u0026amp;copy; 2024 Fried Chicken Menu\u0026lt;/p\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; "
},
{
	"uri": "http://Khoadora.github.io/5-add-response-cards/",
	"title": "Add Response Cards",
	"tags": [],
	"description": "",
	"content": " Here we will add Response Cards into FriedChickenFriend_Simple chatbot. I put the code Lambda handler for response card of at the bottom of the page, you can scroll down to the bottom to see it or follow the link for reference: Code Lambda for response card Content:\nConfigure Response Cards into chatbot. Code Lambda handler for response card. Configure Lambda Response Card Integration. Task 1: Configure Response Cards into chatbot Step 1: Add resonse card for FriedChickenSizes slot Go to Amazon lex console Select bot FriedChickenFriend_Simple Go to intents, select the OrderFriedChicken intent. Scroll down to Slots, select slot FriedChickenSizes, click Advanced options. Scroll down to Slot prompts, select More prompt options. Scroll down to Slot prompts, select Add - Add card group. In the Card group, enter Title as FriedChickenFriend_Simple. In the Subtitle, enter What size fried chicken would you like?. At Buttons, add 4 sizes: small, medium, large, family size. Enter Update prompts. Enter Update slot. Once done, enter Build and Test. We will have the result as shown below. Step 2: Add resonse card for FriedChicken_branch slot Scroll down to Slots, select slot FriedChicken_branch, click Advanced options. Scroll down to Slot prompts, select More prompt options. Scroll down to Slot prompts, select Add - Add card group. In the Card group, enter Title as FriedChickenFriend_Simple. In the Subtitle, enter Where would you like to order your ried chicken from ?. At Buttons, add 3 branch: kfc, jollipee and texas. Enter Update prompts. Enter Update slot. Once done, enter Build and Test. We will have the result as shown below. Step 3: Add resonse card for FriedChicken_Types slot Scroll down to Slots, select slot FriedChicken_Types, click Advanced options. Scroll down to Slot prompts, select More prompt options. Scroll down to Slot prompts, select Add - Add card group. In the Card group, enter Title as FriedChickenFriend_Types. In the Subtitle, enter Where would you like to order your ried chicken from ?. At Buttons, add 5 type: Original Recipe, Extra Crispy, Hot \u0026amp; Spicy, Jollibee Fried Chicken, Classic, Spicy. 5 buttons is maximum.\nEnter Update prompts. Enter Update slot. Once done, enter Build and Test. We will have the result as shown below. You can go back to the web page to see, Response card is also added to the chatbot in the web. Task 2: Code Lambda handler for response card In the Lambda handle for response card code section, I only changed the lambda_handler function in the code in part 3.2, the remaining functions do not have any changes. The changes are as follows: Extracting Information from Event and validating the Order: The bot\u0026rsquo;s name, slots, and intent name are extracted from the event object. The validate_order function is called to validate the user\u0026rsquo;s input (contained in slots). def lambda_handler(event, context): print(event) bot = event[\u0026#39;bot\u0026#39;][\u0026#39;name\u0026#39;] slots = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;slots\u0026#39;] intent = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;name\u0026#39;] order_validation_result = validate_order(slots) print(order_validation_result) Handling Dialog Code Hook and handle Validation Errors if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;DialogCodeHook\u0026#39;: if not order_validation_result[\u0026#39;isValid\u0026#39;]: Prepare Response Message if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;DialogCodeHook\u0026#39;: if not order_validation_result[\u0026#39;isValid\u0026#39;]: response_message = \u0026#39;FriedChickenFriend\u0026#39; if \u0026#39;message\u0026#39; in order_validation_result: response_message = order_validation_result[\u0026#39;message\u0026#39;] response_card_sub_title = \u0026#39;\u0026#39; response_card_buttons = [] Setup Response Card\n4.1 Create title and button for branch\nkfc_sub_title = \u0026#39;Please select a Fried Chicken type\u0026#39; kfc_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Original\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;original\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Extra Crispy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;extra crispy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Hot \u0026amp; Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;hot \u0026amp; spicy\u0026#34; } ] jollipee_sub_title = \u0026#39;Please select a Jollipee type\u0026#39; jollipee_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Classic\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;classic\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;spicy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Sweet Chili\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;sweet chili\u0026#34; } ] texas_sub_title = \u0026#39;Please select a Texas type\u0026#39; texas_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Smoky BBQ\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;smoky bbq\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Cajun Spice\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cajun spice\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Honey Butter\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;honey butter\u0026#34; } ] 4.2 Handles the case when the \u0026ldquo;FriedChickenSizes\u0026rdquo; slot is invalid\nA subtitle prompting the user to select a fried chicken size. Buttons for different sizes (Small, Medium, Large, Family Size) that the user can choose from to correct their input. if order_validation_result[\u0026#39;invalidSlot\u0026#39;] == \u0026#34;FriedChickenSizes\u0026#34;: response_card_sub_title = \u0026#34;Please select a Fried Chicken size\u0026#34; response_card_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Small\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;small\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Medium\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;medium\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Large\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;large\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Family Size\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;family size\u0026#34; } ] 4.3 Handles the situation when the \u0026ldquo;FriedChicken_branch\u0026rdquo; slot is invalid\nA subtitle instructing the user to select a fried chicken franchise. Buttons for three franchises: KFC, Jollipee, and Texas. Each button has a label and a value that will be sent back when the user makes a selection. if order_validation_result[\u0026#39;invalidSlot\u0026#39;] == \u0026#34;FriedChicken_branch\u0026#34;: response_card_sub_title = \u0026#34;Please select a Fried Chicken franchise\u0026#34; response_card_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;KFC\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;kfc\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Jollipee\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;jollipee\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Texas\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;texas\u0026#34; } ] if order_validation_result[\u0026#39;invalidSlot\u0026#39;] == \u0026#34;FriedChicken_Types\u0026#34;: if order_validation_result[\u0026#39;invalidFranchise\u0026#39;] == \u0026#34;kfc\u0026#34;: response_card_sub_title = kfc_sub_title response_card_buttons = kfc_buttons elif order_validation_result[\u0026#39;invalidFranchise\u0026#39;] == \u0026#34;jollipee\u0026#34;: response_card_sub_title = jollipee_sub_title response_card_buttons = jollipee_buttons elif order_validation_result[\u0026#39;invalidFranchise\u0026#39;] == \u0026#34;texas\u0026#34;: response_card_sub_title = texas_sub_title response_card_buttons = texas_buttons else: response_card_sub_title = \u0026#39;Please select a fried chicken type\u0026#39; response_card_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Original\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;original\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Extra Crispy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;extra crispy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Hot \u0026amp; Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;hot \u0026amp; spicy\u0026#34; } , { \u0026#34;text\u0026#34;: \u0026#34;Classic\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;classic\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;spicy\u0026#34; } ] Create Response Constructs a response that prompts the user to provide the correct slot value, displaying an image response card with buttons to select options based on the invalid slot. response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;slotToElicit\u0026#34;: order_validation_result[\u0026#39;invalidSlot\u0026#39;], \u0026#34;type\u0026#34;: \u0026#34;ElicitSlot\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots, } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;ImageResponseCard\u0026#34;, \u0026#34;content\u0026#34;: response_message, \u0026#34;imageResponseCard\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;FriedChickenFriend\u0026#34;, \u0026#34;subtitle\u0026#34;: response_card_sub_title, \u0026#34;buttons\u0026#34;: response_card_buttons } } ] } Delegate to Lex If the order is valid, this block creates a response to delegate the processing back to Lex to continue handling the conversation. else: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Delegate\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#39;name\u0026#39;: intent, \u0026#39;slots\u0026#39;: slots } } } Create Fulfillment Response Constructs a response to indicate that the order has been successfully placed and closes the dialog with Lex. The message \u0026ldquo;I\u0026rsquo;ve placed your order.\u0026rdquo; is sent to the user. if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;FulfillmentCodeHook\u0026#39;: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Close\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots, \u0026#34;state\u0026#34;: \u0026#34;Fulfilled\u0026#34; } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;PlainText\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;I\u0026#39;ve placed your order.\u0026#34; } ] } print(response) return response Task 3: Configure Lambda Response Card Integration. Copy the code and put it into lambda function, enter Deploy. Go to Intent: OrderFriedChicken, enter Build and Test. You can see when I chose the wrong type of Jollipee, the chatbot asked me to choose again, that is the application of Response Card in Lambda function.\nComplete Lambda handler for response card code: import json friedChickenSizes = [\u0026#39;small\u0026#39;, \u0026#39;medium\u0026#39;, \u0026#39;large\u0026#39;, \u0026#39;family size\u0026#39;] friedChicken_branch = [\u0026#39;kfc\u0026#39;, \u0026#39;jollipee\u0026#39;, \u0026#39;texas\u0026#39;] kfc_types = [\u0026#39;original\u0026#39;, \u0026#39;extra crispy\u0026#39;, \u0026#39;hot \u0026amp; spicy\u0026#39;] jollipee_types = [\u0026#39;classic\u0026#39;, \u0026#39;spicy\u0026#39;, \u0026#39;sweet chili\u0026#39;] texas_types = [\u0026#39;smoky bbq\u0026#39;, \u0026#39;cajun spice\u0026#39;, \u0026#39;honey butter\u0026#39;] def validate_order(slots): # Validate FriedChickenSizes if not slots[\u0026#39;FriedChickenSizes\u0026#39;]: print(\u0026#39;Validating FriedChickenSizes Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChickenSizes\u0026#39; } if slots[\u0026#39;FriedChickenSizes\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in friedChickenSizes: print(\u0026#39;Invalid FriedChickenSizes\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChickenSizes\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a {} fried chicken size.\u0026#39;.format(\u0026#34;, \u0026#34;.join(friedChickenSizes)) } # Validate FriedChicken_branch if not slots[\u0026#39;FriedChicken_branch\u0026#39;]: print(\u0026#39;Validating FriedChicken_branch Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_branch\u0026#39; } if slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in friedChicken_branch: print(\u0026#39;Invalid FriedChickenSizes\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_branch\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select from {} fried chicken branch.\u0026#39;.format(\u0026#34;, \u0026#34;.join(friedChicken_branch)) } # Validate FriedChicken_Types if not slots[\u0026#39;FriedChicken_Types\u0026#39;]: print(\u0026#39;Validating FriedChicken_Types Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;invalidFranchise\u0026#39;: \u0026#39;\u0026#39; } # Validate FriedChicken_Types for FriedChicken_branch if slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() == \u0026#39;kfc\u0026#39;: if slots[\u0026#39;FriedChicken_Types\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in kfc_types: print(\u0026#39;Invalid FriedChicken_Types for KFC\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;invalidFranchise\u0026#39;: \u0026#39;kfc\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a KFC type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(kfc_types)) } if slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() == \u0026#39;jollipee\u0026#39;: if slots[\u0026#39;FriedChicken_Types\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in jollipee_types: print(\u0026#39;Invalid FriedChicken_Types for Jollipee\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;invalidFranchise\u0026#39;: \u0026#39;jollipee\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a Jollipee type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(jollipee_types)) } if slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() == \u0026#39;texas\u0026#39;: if slots[\u0026#39;FriedChicken_Types\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in texas_types: print(\u0026#39;Invalid FriedChicken_Types for Texas\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;invalidFranchise\u0026#39;: \u0026#39;texas\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a Texas type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(texas_types)) } # Valid Order return {\u0026#39;isValid\u0026#39;: True} def lambda_handler(event, context): print(event) bot = event[\u0026#39;bot\u0026#39;][\u0026#39;name\u0026#39;] slots = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;slots\u0026#39;] intent = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;name\u0026#39;] order_validation_result = validate_order(slots) print(order_validation_result) if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;DialogCodeHook\u0026#39;: if not order_validation_result[\u0026#39;isValid\u0026#39;]: response_message = \u0026#39;FriedChickenFriend\u0026#39; if \u0026#39;message\u0026#39; in order_validation_result: response_message = order_validation_result[\u0026#39;message\u0026#39;] response_card_sub_title = \u0026#39;\u0026#39; response_card_buttons = [] kfc_sub_title = \u0026#39;Please select a Fried Chicken type\u0026#39; kfc_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Original\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;original\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Extra Crispy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;extra crispy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Hot \u0026amp; Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;hot \u0026amp; spicy\u0026#34; } ] jollipee_sub_title = \u0026#39;Please select a Jollipee type\u0026#39; jollipee_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Classic\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;classic\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;spicy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Sweet Chili\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;sweet chili\u0026#34; } ] texas_sub_title = \u0026#39;Please select a Texas type\u0026#39; texas_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Smoky BBQ\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;smoky bbq\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Cajun Spice\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cajun spice\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Honey Butter\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;honey butter\u0026#34; } ] if order_validation_result[\u0026#39;invalidSlot\u0026#39;] == \u0026#34;FriedChickenSizes\u0026#34;: response_card_sub_title = \u0026#34;Please select a Fried Chicken size\u0026#34; response_card_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Small\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;small\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Medium\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;medium\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Large\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;large\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Family Size\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;family size\u0026#34; } ] if order_validation_result[\u0026#39;invalidSlot\u0026#39;] == \u0026#34;FriedChicken_branch\u0026#34;: response_card_sub_title = \u0026#34;Please select a Fried Chicken franchise\u0026#34; response_card_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;KFC\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;kfc\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Jollipee\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;jollipee\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Texas\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;texas\u0026#34; } ] if order_validation_result[\u0026#39;invalidSlot\u0026#39;] == \u0026#34;FriedChicken_Types\u0026#34;: if order_validation_result[\u0026#39;invalidFranchise\u0026#39;] == \u0026#34;kfc\u0026#34;: response_card_sub_title = kfc_sub_title response_card_buttons = kfc_buttons elif order_validation_result[\u0026#39;invalidFranchise\u0026#39;] == \u0026#34;jollipee\u0026#34;: response_card_sub_title = jollipee_sub_title response_card_buttons = jollipee_buttons elif order_validation_result[\u0026#39;invalidFranchise\u0026#39;] == \u0026#34;texas\u0026#34;: response_card_sub_title = texas_sub_title response_card_buttons = texas_buttons else: response_card_sub_title = \u0026#39;Please select a fried chicken type\u0026#39; response_card_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Original\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;original\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Extra Crispy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;extra crispy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Hot \u0026amp; Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;hot \u0026amp; spicy\u0026#34; } , { \u0026#34;text\u0026#34;: \u0026#34;Classic\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;classic\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;spicy\u0026#34; } ] response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;slotToElicit\u0026#34;: order_validation_result[\u0026#39;invalidSlot\u0026#39;], \u0026#34;type\u0026#34;: \u0026#34;ElicitSlot\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots, } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;ImageResponseCard\u0026#34;, \u0026#34;content\u0026#34;: response_message, \u0026#34;imageResponseCard\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;FriedChickenFriend\u0026#34;, \u0026#34;subtitle\u0026#34;: response_card_sub_title, \u0026#34;buttons\u0026#34;: response_card_buttons } } ] } else: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Delegate\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#39;name\u0026#39;: intent, \u0026#39;slots\u0026#39;: slots } } } if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;FulfillmentCodeHook\u0026#39;: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Close\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots, \u0026#34;state\u0026#34;: \u0026#34;Fulfilled\u0026#34; } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;PlainText\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;I\u0026#39;ve placed your order.\u0026#34; } ] } print(response) return response "
},
{
	"uri": "http://Khoadora.github.io/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.5.-create-intent-texas_branch-and-slot-types-texas_types/",
	"title": "Create intent Texas_branch and Slot types Texas_types",
	"tags": [],
	"description": "",
	"content": "Task 1: Create intent Texas_branch At Intent name enter Texas_branch. At Sample utterances enter in Add utterance is Texas. At Initial response enter message is Okey, You would like Texas fried chicken. Click Save intent and back to intents list Task 2: Create Slot types Texas_types for intent Texas_branch Click Slot types. Click Add slot type - Add blank slot type. Enter name slot type is Texas_types. At Slot value resolution, select Expand values (default) At Slot type values, enter values are Smoky BBQ, Cajun Spice, Honey Butter. Enter Save Slot type Task 3: Add Slot types Texas_types to the intent Texas_branch Next, Back to intents list, select intent name Texas_branch. Scroll down Slots - Add slot. At slot type, select Texas_types At Name, enter Texas_types At Prompts, enter Which Texas fried chicken would you like(Smoky BBQ, Cajun Spice, Honey Butter) ?. Click Add. Scroll down Confirmation. In the confirmation prompt, I\u0026rsquo;ll write Nice ! Would you like me to order your {Texas_types} ?. Where {Texas_types} will be the value the user chooses from Slots.\nIn case the user answers No, I will set the Decline response for the bot to respond as Bummer! Stay hungry, my friend. * Scroll down Fulfillment. I will notify user of status when completed at On successful fulfillment as Okay, your order is on its way. Would you like to order another fried chicken, a side, or a drink ?. In case of failure as Oh no! Something went wrong. Please try again. * Click Save intent and Build. After Build, click Test and enter the messages to test as below. "
},
{
	"uri": "http://Khoadora.github.io/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.6.-create-intent-sideorder-and-slot-types-side_types/",
	"title": "Create intent SideOrder and Slot types Side_types",
	"tags": [],
	"description": "",
	"content": "Task 1: Create intent SideOrder At Intent name enter SideOrder. At Sample utterances enter in Add utterance is I want to order a side, Side, A side, Side order. At Initial response enter message is Okey, You would like to order a side.. Click Save intent and back to intents list. Task 2: Create Slot types Side_types for intent SideOrder Click Slot types. Click Add slot type - Add blank slot type. Enter name slot type is Texas_types. At Slot value resolution, select Expand values (default) At Slot type values, enter values are Fries, Orion Rings, Tater Tots. Enter Save Slot type Task 3: Add Slot types Side_types to the intent SideOrder Next, Back to intents list, select intent name SideOrder. Scroll down Slots - Add slot. At slot type, select Side_types At Name, enter Side_types At Prompts, enter Which side would you like (Fries, Onion Rings or Tater Tots) ?. Click Add. Scroll down Confirmation. In the confirmation prompt, I\u0026rsquo;ll write Nice ! Would you like me to order your {Side_types} ?. Where {Side_types} will be the value the user chooses from Slots.\nIn case the user answers No, I will set the Decline response for the bot to respond as Bummer! Stay hungry, my friend. * Scroll down Fulfillment. I will notify user of status when completed at On successful fulfillment as Okay, your order is on its way. Would you like to order another fried chicken, a side, or a drink ?. In case of failure as Oh no! Something went wrong. Please try again. * Click Save intent and Build. After Build, click Test and enter the messages to test as below. "
},
{
	"uri": "http://Khoadora.github.io/6-slack-integration/",
	"title": "Slack Integration",
	"tags": [],
	"description": "",
	"content": "Slack is a popular team communication platform that allows integration of multiple applications to automate workflows.\nIntegrating Amazon Lex into Slack automates communication, improves user experience, and harnesses the power of the AWS ecosystem. This allows Slack users to interact with intelligent bots to handle requests quickly and efficiently, from customer support to task management.\nGo to Amazon lex console Select bot FriedChickenFriend_Simple Select Channel integrations - Add chanel. At Platform, select Slack. Enter name is FriedChickenFriend. At Alias, select TestBotAlias. Language select English (US). Go to Slack. Enter Get started and log in with your student email or work email to use it for free. Enter your name of you for app. Enter name of chatbot for app. Select Start with free. This is the Slack workspace interface. Now that the workspace is initialized, I\u0026rsquo;ll move on to api.slack.com/apps Select Create an App. Select From scratch Enter App Name is FriedChickenFriend. Pick a workspace to develop your app in, select Student. Click Create App. Copy Client ID, Client Secret and Verification Token to put into amazon lex. Select Interactivity and Shortcuts, turn On. At Request URL, enter https:\\slack.com. Select Save changes. Go back to the Additional configuration section of Channel integrations in Amazon Lex. Enter Client ID, Client Secret and Verification Token from Api Slack. Click Add. Select Chanel name is FriedChickenFriend. Copy Endpoint and OAuth endpoint and make a note of them. Go back to Api Slack, select OAuth \u0026amp; Permissions. In Redirect URLs, put OAuth endpoint from Amazon Lex in. Enter Save URLs. Scroll down to Scopes, enter Add scope is chat:write and team:read. Select Interactivity and Shortcuts, change Request URL to the Endpoint code from Amazon Lex. Enter Save changes. Select Event Subscriptions, turn On. At Request URL enter Endpoint code from Amazon Lex. Add Bot User Event is messenge:im. Enter Save changes. Select App Home. Scroll down to Show Tabs, check Allow users to send Slash commands and messages from the messages tab. Select Manage Distribution - Add to Slack. Select *Allow. Select bot FriedChickenFriend and check to complete.\n"
},
{
	"uri": "http://Khoadora.github.io/7-clear-up/",
	"title": "Clear up",
	"tags": [],
	"description": "",
	"content": "Overview We will now tear down all of the potentially-chargeable resources created by the Banker Bot Workshop:\nRemove the FriedChickenFriend and FriedChickenFriend_Simple from Amazon Lex Remove the associated Lambda function Remove the Lambda function\u0026rsquo;s log files Once these steps have been completed there should be no potentially-chargeable resources left in your account.\nTask 1: Remove the FriedChickenFriend and FriedChickenFriend_Simple from Amazon Lex Navigate back to the Amazon Lex console, and click on the Bots menu on the left-hand sidebar. This will show a full list of all bots that you have defined. Click the radio button next to the FriedChickenFriend entry and then select Delete from the Action drop-down. Enter Delete to confirm. Do the same with the FriedChickenFriend_Simple bot Task 2: Remove the Lambda function Navigate to the AWS Lambda console, and click on the Functions menu on the left-hand sidebar. This will show a full list of all Lambda functions that you have defined. Clic on the radio button next to the BankingBotEnglish entry and select Delete from the Action drop-down. Enter Delete to confirm. Task 3: Remove the Lambda function log files Navigate to the CloudWatch service, using the same methods that you used to navigate to the other service pages, and click on Logs on the left-hand sidebar, followed by its sub-entry Log groups. In the search bar, type in BankingBot to filter the list of log groups, and you should see the one for the Lambda function that you\u0026rsquo;ve just deleted. Click on the check-box, then select Delete log group(s) in the Actions menu. Enter Delete to confirm. "
},
{
	"uri": "http://Khoadora.github.io/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.7.-create-intent-drinkorder-and-slot-types-drink_types/",
	"title": "Create intent DrinkOrder and Slot types Drink_types",
	"tags": [],
	"description": "",
	"content": "Task 1: Create intent DrinkOrder At Intent name enter DrinkOrder. At Sample utterances enter in Add utterance is I want to order a drink, Drink, A drink, drink order. At Initial response enter message is Okey, You would like to order a drink.. Click Save intent and back to intents list. Task 2: Create Slot types Drink_types for intent DrinkOrder Click Slot types. Click Add slot type - Add blank slot type. Enter name slot type is Drink_types. At Slot value resolution, select Expand values (default) At Slot type values, enter values are Soda, Beer, Coca. Enter Save Slot type Task 3: Add Slot types Drink_types to the intent DrinkOrder Next, Back to intents list, select intent name DrinkOrder. Scroll down Slots - Add slot. At slot type, select Drink_types At Name, enter Drink_types At Prompts, enter Which side would you like (Soda, Beer or Coca) ?. Click Add. Scroll down Confirmation. In the confirmation prompt, I\u0026rsquo;ll write Nice ! Would you like me to order your {Drink_types} ?. Where {Drink_types} will be the value the user chooses from Slots.\nIn case the user answers No, I will set the Decline response for the bot to respond as Bummer! Stay hungry, my friend. Scroll down Fulfillment. I will notify user of status when completed at On successful fulfillment as Okay, your order is on its way. Would you like to order another fried chicken, a side, or a drink ?. In case of failure as Oh no! Something went wrong. Please try again. Click Save intent and Build. After Build, click Test and enter the messages to test as below. "
},
{
	"uri": "http://Khoadora.github.io/",
	"title": "Amazon Lex Workshops",
	"tags": [],
	"description": "",
	"content": "Amazon Lex Workshops Overview Amazon Lex is an AWS service that enables you to create intelligent conversational interfaces using voice and text. With Amazon Lex, you can easily build conversational bots, customer service applications, or automated chatbots to interact with users in a natural way.\nComponents of Amazon Lex bot: Intents - this is an action that the user wants to perform. It enables the bot to understand and classify what task is user to trying to accomplish. A single bot can contain multiple different intents, allowing one bot to handle different - but most-likely related - requests from a user\nUtterances - these are the textual representations of what a user has to type or say in order to trigger an intent. One intent can contain many different utterances, allowing users to trigger the bot using different phrases, potentially supply many different data parameters (or \u0026ldquo;slots\u0026rdquo;) with their utterance\nPrompts - Amazon Lex can define a different prompt for different stages of the conversation, such as when asking for a bank account number or a date for flight booking. They can also be overridden at run-time by your Lambda functions\nSlots - these are the data items that the bot intent needs in order to be able to fulfill its task; e.g. for a flight booking intent you are likely to need slots for origin airport, destination airport, flight day, flight time, and booking class. Amazon Lex has a large number of built-in slot types, but you are free to create your own custom slot types for your use case\nFulfilment - this is the final state of the intent, normally with a closing message and some additional information for the user; e.g. for a flight booking you could confirm that the flight is booked, along with a brief summary of the route and the flight number that the user has been booked onto\nHow Amazon Lex Works?\nAmazon Lex helps build conversational interfaces that integrate with voice and text applications. The process begins with defining the problem to be solved and the desired outcome, then the chatbot receives a request (Intent), gets data from the user (Utterance), requests additional information (Prompt), collects the required data (Slot), and finally performs an action to complete the request (Fulfillment). Once complete, the chatbot is tested and deployed to production.\nWorkshop Objectives: After completing this workshop, you will learn how to create a chatbot with multiple intents and Lambda handlers, add response tags. You can also create a standalone website for your existing Amazon Lex bot or embed it into your existing website. You can also apply the chatbot to the Slack application to facilitate communication and work.\nContents: Introduction Build a ChatBot to order Fried Chicken Validate Slot data with Lambda Integrate ChatBot into a Web Page Add Response Cards Slack Integration Clean up References: Amazon Lex (ChatBot) by Cumulus Cycles, accessed on 01/09/2024. Amazon Lex Workshop by AWS, accessed on 02/09/2024. Amazon Lex by Wikipedia, accessed on 02/09/2024. Create an AWS Account, accessed on 20/09/2024. "
},
{
	"uri": "http://Khoadora.github.io/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.8.-configure-intent-fallbackintent/",
	"title": "Configure intent FallbackIntent",
	"tags": [],
	"description": "",
	"content": " Select intent FallbackIntent. Scroll down Closing response. Add the message is Sorry, I can't assist with that. Save intent and build, We can see the difference in the picture. "
},
{
	"uri": "http://Khoadora.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://Khoadora.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]