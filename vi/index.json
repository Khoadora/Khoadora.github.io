[
{
	"uri": "http://Khoadora.github.io/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Mục tiêu của các Workshop: Sau khi hoàn thành workshop này, bạn sẽ học được cách:\nTạo một chatbot với nhiều ý định (intent) và các hàm Lambda handler, thêm các thẻ phản hồi (response tags). Tạo một trang web độc lập cho bot Amazon Lex hiện có của bạn hoặc nhúng nó vào trang web hiện có của bạn. Ứng dụng chatbot vào ứng dụng Slack để hỗ trợ giao tiếp và làm việc. Kiến trúc của Workshop: Kiến trúc này mô tả hệ thống chatbot tích hợp Slack và trang web với các dịch vụ AWS. Người dùng tương tác qua Slack hoặc trang web, yêu cầu được chuyển đến Amazon API Gateway, sau đó đến Amazon Lex để xử lý ngôn ngữ tự nhiên. Lambda thực hiện các logic ứng dụng, trong khi Amazon Polly có thể tạo phản hồi giọng nói. IAM Role đảm bảo các quyền truy cập giữa các dịch vụ, và CloudWatch giám sát hệ thống và ghi lại log. Yêu cầu trước khi tham gia Workshop: Tài khoản của bạn phải có khả năng tạo các vai trò IAM mới và mở rộng các quyền IAM khác. Nếu bạn đã có tài khoản AWS và có quyền Truy cập Quản trị viên IAM, bạn có thể bỏ qua hoàn toàn trang này và chuyển sang bước tiếp theo.\nNếu bạn chưa có tài khoản AWS với quyền Truy cập Quản trị viên, hãy tạo ngay tại đây bằng cách nhấn vào nút Create an AWS Account.\nKhi bạn đã có tài khoản AWS, hãy đảm bảo bạn đang thực hiện các bước workshop tiếp theo với tư cách là người dùng IAM có quyền quản trị viên cho tài khoản AWS - mở liên kết này và làm theo các hướng dẫn dưới đây: Tạo một người dùng IAM mới để sử dụng cho workshop\nChọn Users trong danh sách lệnh bên trái, nhấn nút Add User, nhập User name và nhấn nút Next.\nTrong Permissions options, gán AdministratorAccess IAM Policy bằng cách chọn từ danh sách các chính sách quyền hiện có, sau đó nhấn nút Next.\nXem lại các lựa chọn của bạn, nếu bạn hài lòng thì nhấn nút Create user. Nếu muốn thay đổi gì đó, nhấn nút Previous.\nKết quả cuối cùng sẽ như sau:\nLưu ý: Phần trên được tham chiếu và lấy hình ảnh từ Tạo một tài khoản AWS Nội dung: Tạo một ChatBot để đặt Gà Rán Xác thực dữ liệu Slot với Lambda Tích hợp ChatBot vào một Trang Web Thêm các Thẻ Phản hồi Tích hợp với Slack Dọn dẹp "
},
{
	"uri": "http://Khoadora.github.io/vi/2-build-a-chatbot/2.1-create-bot-and-configure/",
	"title": "Tạo bot và Cấu hình",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ tìm hiểu cách tạo và cấu hình bot có tên \u0026ldquo;FriedChickenFriend\u0026rdquo; trên Amazon Lex.\nNhiệm vụ 1: Cấu hình cài đặt bot Vào Amazon lex management console\nNhấp vào Create bot. Trong Creation method, nhấp vào Traditional - Create a blank bot. Trong Bot configuration, nhập Bot name là FriedChickenFriend. Trong IAM permissions, nhấp vào Tạo vai trò với quyền Amazon Lex cơ bản..\nTrong Children’s Online Privacy Protection Act (COPPA), nhấp vào No.\nNhấp vào Next. Nhiệm vụ 2: Thêm ngôn ngữ Trong Select language, chọn English (US). Trong Voice interaction, chọn Matthew. Trong Intent classification confidence score threshold, nhập 0,04. Nhấp vào Done. Nhiệm vụ 3: Kiểm tra Quay lại màn hình quản lý lex của Amazon, chúng ta thấy bot FriedChickenFriend đã được tạo. "
},
{
	"uri": "http://Khoadora.github.io/vi/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.1.-create-intent-greeting/",
	"title": "Tạo intent Greeting",
	"tags": [],
	"description": "",
	"content": " Tại Intent name, nhập Greeting.\nTại Sample utterances, nhập vào Add utterance là Hello, Hi, Hey FriedChickenFriend.\nTại Closing response, nhập vào Messege là Hello, Welcome to FriedChickenFriend. Would you like to order a Fried Chicken? và nhập vào Variations là Hello! Would you like to order Fried Chicken for lunch?, Hi there!, I'm a FriedChickenFriend bot. Would you like to order a Fried Chicken?.\nNhấn Save intent và Build.\nLần build đầu tiên có thể mất vài phút.\nSau khi build, nhấn Test và nhập các utterances để kiểm tra như bên dưới.\n"
},
{
	"uri": "http://Khoadora.github.io/vi/3-validate-slot-data-with-lambda/3.1-rebuilding-a-simpler-chatbot/",
	"title": "Xây dựng lại chatbot đơn giản",
	"tags": [],
	"description": "",
	"content": " Ở đây, chúng ta sẽ xây dựng lại một chatbot đặt hàng gà rán đơn giản hơn phiên bản cũ (phần 2) mà không có món phụ hoặc đồ uống để đơn giản hóa việc triển khai Lambda. Lưu ý rằng bạn vẫn có thể thêm xác nhận để bổ sung món phụ hoặc đồ uống để nâng cao dự án. Sau đây là bảng tóm tắt tất cả các loại Intent và Slot mà chúng ta sẽ tạo trong phần này: Nội dung:\nTạo bot và các loại Slot. Tạo Intent. 3.1.1. Tạo bot và Slot types Task 1: Tạo bot Step 1: Cấu hình bot settings Truy cập vào Amazon Lex Management Console.\nNhấn Create bot.\nỞ mục Creation method, chọn Traditional - Create a blank bot.\nỞ Bot configuration, nhập Bot name là FriedChickenFriend_Simple.\nTrong IAM permissions, chọn Create a role with basic Amazon Lex permissions.\nỞ Children’s Online Privacy Protection Act (COPPA), chọn No.\nNhấn Next.\nStep 2: Thêm ngôn ngữ Ở Select language, chọn English (US). Ở Voice interaction, chọn Matthew. Ở Intent classification confidence score threshold, nhập 0.04. Nhấn Done.\nTask 2: Tạo Slot types Step 1: Tạo Slot type FriedChickenSizes Nhấn Slot types. Nhấn Add slot type → Add blank slot type.\nNhập tên slot type là FriedChickenSizes.\nỞ Slot value resolution, chọn Expand values (default). Ở Slot type values, nhập các giá trị là Small, Medium, Large, Family Size. Nhấn Save Slot type.\nStep 2: Tạo Slot type FriedChicken_branch Quay lại Slot types. Nhấn Add slot type → Add blank slot type. Nhập tên slot type là FriedChicken_branch.\nỞ Slot value resolution, chọn Expand values (default). Ở Slot type values, nhập các giá trị là KFC, Jollipee, Texas. Nhấn Save Slot type.\nStep 3: Tạo Slot type FriedChicken_Types Quay lại Slot types. Nhấn Add slot type → Add blank slot type. Nhập tên slot type là FriedChicken_Types.\nỞ Slot value resolution, chọn Expand values (default). Ở Slot type values, nhập các giá trị là Original Recipe, Extra Crispy, Hot \u0026amp; Spicy, Classic, Spicy, Sweet Chili, Smoky BBQ, Cajun Spice, Honey Butter. Nhấn Save Slot type.\n3.1.2. Tạo intent OrderFriedChicken Ở Intent name, nhập OrderFriedChicken.\nCuộn xuống Slots → Add slot. Tại đây, chúng ta sẽ thêm 3 loại slot đã tạo ở bước 3.1.1 với cùng phương pháp như phần 2.\nCác tên slot là FriedChickenSizes, FriedChicken_branch và FriedChicken_Types.\nỞ Sample utterances, nhập các câu như trong hình dưới.\nTrong đó, {FriedChickenSizes}, {FriedChicken_Types} và {FriedChicken_branch} sẽ là các giá trị mà người dùng chọn từ Slots.\nCuộn xuống Confirmation. Trong prompt xác nhận, viết Would you like me to order your {FriedChickenSizes} {FriedChicken_Types} from {FriedChicken_branch} ?.\nTrong đó, {FriedChickenSizes}, {FriedChicken_Types} và {FriedChicken_branch} sẽ là các giá trị mà người dùng chọn từ Slots.\nTrong trường hợp người dùng trả lời No, đặt Decline response cho bot trả lời Stay hungry, my friend.\nCuộn xuống Fulfillment. Ở On successful fulfillment, bot sẽ trả lời Ive ordered your {FriedChickenSizes} {FriedChicken_Types} from {FriedChicken_branch}.`\nIn case of failure, bot sẽ trả lời Oop, Something went wrong, please try again.\nNhấn Save intent và Build.\nSau khi Build, nhấn Test và nhập các tin nhắn để thử nghiệm như hình dưới.\nKhi tôi đặt Sweet Chili từ KFC, vấn đề là chi nhánh KFC không có Sweet Chili, Sweet Chili đến từ chi nhánh Jollipee, vì vậy tôi sẽ nói No. Nhưng bây giờ chúng ta cần một cách để xác thực đầu vào của người dùng. Nếu người dùng cố đặt Sweet Chili từ KFC, chúng ta sẽ không cho phép bot thực hiện và sẽ nhắc người dùng cung cấp dữ liệu phù hợp. Để làm điều đó, chúng ta sẽ sử dụng Lambda.\n"
},
{
	"uri": "http://Khoadora.github.io/vi/3-validate-slot-data-with-lambda/3.2-use-a-lambda-functions-for-chatbot/",
	"title": "Sử dụng Lambda function cho chatbot",
	"tags": [],
	"description": "",
	"content": " Ở đây chúng ta sẽ thêm một hàm Lambda vào chatbot FriedChickenFriend_Simple để xác thực dữ liệu đầu vào của người dùng. Tôi đặt mã hàm Lambda ở cuối trang, bạn có thể cuộn xuống cuối để xem hoặc theo liên kết để tham khảo: Mã hàm Lambda Nội dung:\nTạo hàm Lambda. Thêm hàm Lambda vào chatbot. Task 1: Tạo hàm Lambda Truy cập AWS Lambda.\nNhấn Create a function. Chọn Author from scratch.\nFunction name là FriedChickenOrder.\nRuntime chọn Python 3.12.\nArchitecture chọn x86_64.\nNhấn Create function. Kết quả sau khi khởi tạo sẽ như hình dưới: Dưới đây là Đoạn 2 đã được thay thế hình ảnh bằng đoạn code tương ứng từ Đoạn 1:\nĐoạn 2:\nTiếp theo, chúng ta sẽ viết mã cho hàm Lambda cho chatbot của mình. Tôi đã chuẩn bị và sẽ giải thích chức năng của từng đoạn mã:\nNhập các phụ thuộc Mô-đun json được nhập. Mô-đun này thường được sử dụng để xử lý dữ liệu JSON, chẳng hạn như phân tích hoặc tuần tự hóa các đối tượng JSON. import json Định nghĩa biến Các biến này định nghĩa các tùy chọn có sẵn cho kích thước, các chi nhánh gà rán (KFC, Jollibee, Texas) và các loại gà tương ứng cho mỗi chi nhánh. friedChickenSizes liệt kê các tùy chọn kích thước có sẵn. friedChicken_branch liệt kê các chuỗi thức ăn nhanh có sẵn. kfc_types, jollipee_types, và texas_types lưu trữ các loại gà khác nhau cụ thể cho mỗi chi nhánh. friedChickenSizes = [\u0026#39;small\u0026#39;, \u0026#39;medium\u0026#39;, \u0026#39;large\u0026#39;, \u0026#39;family size\u0026#39;] friedChicken_branch = [\u0026#39;kfc\u0026#39;, \u0026#39;jollipee\u0026#39;, \u0026#39;texas\u0026#39;] kfc_types = [\u0026#39;original\u0026#39;, \u0026#39;extra crispy\u0026#39;, \u0026#39;hot \u0026amp; spicy\u0026#39;] jollipee_types = [\u0026#39;classic\u0026#39;, \u0026#39;spicy\u0026#39;, \u0026#39;sweet chili\u0026#39;] texas_types = [\u0026#39;smoky bbq\u0026#39;, \u0026#39;cajun spice\u0026#39;, \u0026#39;honey butter\u0026#39;] Định nghĩa hàm validate_order Hàm này xác thực đầu vào nhận được từ người dùng thông qua chatbot. Nó kiểm tra xem các giá trị được cung cấp cho kích thước, chi nhánh và loại gà rán có hợp lệ hay không. def validate_order(slots): 3.1 Xác thực FriedChickenSizes\nKiểm tra đầu tiên: Nếu slot FriedChickenSizes trống, nó đánh dấu slot này là không hợp lệ và trả về phản hồi thích hợp để nhắc người dùng chọn một kích thước. Kiểm tra thứ hai: Nó xác minh xem kích thước đã chọn có tồn tại trong danh sách FriedChickenSizes hay không. Nếu không, nó nhắc người dùng với một thông điệp yêu cầu chọn một trong các tùy chọn hợp lệ. def validate_order(slots): # Validate FriedChickenSizes if \u0026#39;FriedChickenSizes\u0026#39; not in slots or not slots[\u0026#39;FriedChickenSizes\u0026#39;]: print(\u0026#39;Validating FriedChickenSizes Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChickenSizes\u0026#39; } if slots[\u0026#39;FriedChickenSizes\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in friedChickenSizes: print(\u0026#39;Invalid FriedChickenSizes\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChickenSizes\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a {} burger size.\u0026#39;.format(\u0026#34;, \u0026#34;.join(friedChickenSizes)) } 3.2 Xác thực FriedChicken_branch và FriedChickenType\nKiểm tra đầu tiên: Tương tự như kiểm tra trước, phần này kiểm tra xem slot FriedChicken_branch có được cung cấp hay không. Kiểm tra thứ hai: Nó xác thực xem chi nhánh đã cung cấp (ví dụ: KFC, Jollibee) có tồn tại trong danh sách FriedChicken_branch hay không. Nếu không hợp lệ, một nhắc nhở được trả về để chọn từ các chi nhánh hợp lệ. Kiểm tra đầu tiên: Phần này kiểm tra xem slot FriedChicken_Types có được cung cấp hay không. # Validate FriedChicken_branch if \u0026#39;FriedChicken_branch\u0026#39; not in slots or not slots[\u0026#39;FriedChicken_branch\u0026#39;]: print(\u0026#39;Validating FriedChicken_branch Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_branch\u0026#39; } if slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in friedChicken_branch: print(\u0026#39;Invalid FriedChicken_branch\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_branch\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select from {} burger franchises.\u0026#39;.format(\u0026#34;, \u0026#34;.join(friedChicken_branch)) } # Validate FriedChicken_Types if \u0026#39;FriedChicken_Types\u0026#39; not in slots or not slots[\u0026#39;FriedChicken_Types\u0026#39;]: print(\u0026#39;Validating FriedChicken_Types Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39; } 3.3 Xác thực FriedChicken_Types dựa trên chi nhánh và trường hợp đơn hàng hợp lệ\nPhần này đảm bảo rằng loại gà mà người dùng chọn là hợp lệ cho chi nhánh cụ thể mà họ chọn (KFC, Jollibee, Texas). Nếu một loại không hợp lệ, chatbot sẽ nhắc người dùng chọn một tùy chọn hợp lệ cho chi nhánh đã chọn. Nếu tất cả các kiểm tra trên đều vượt qua, hàm sẽ trả về {'isValid': True} chỉ ra rằng đơn hàng là hợp lệ. # Validate FriedChicken_Types for FriedChicken_branch branch_value = slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() type_value = slots[\u0026#39;FriedChicken_Types\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() if branch_value == \u0026#39;kfc\u0026#39;: if type_value not in kfc_types: print(\u0026#39;Invalid FriedChicken_Types for KFC\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a KFC type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(kfc_types)) } elif branch_value == \u0026#39;jollipee\u0026#39;: if type_value not in jollipee_types: print(\u0026#39;Invalid FriedChicken_Types for Jollipee\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a Jollipee type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(jollipee_types)) } elif branch_value == \u0026#39;texas\u0026#39;: if type_value not in texas_types: print(\u0026#39;Invalid FriedChicken_Types for Texas\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a Texas type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(texas_types)) } # Valid Order return {\u0026#39;isValid\u0026#39;: True} Định nghĩa hàm lambda_handler Hàm lambda_handler xử lý các sự kiện đến (từ một chatbot, chẳng hạn). Nó nhận hai tham số: event: Chi tiết sự kiện, bao gồm các slot chứa thông tin đơn hàng của người dùng. context: Thông tin runtime cho hàm Lambda (không được sử dụng ở đây). def lambda_handler(event, context): print(event) 4.1 Trích xuất thông tin từ sự kiện và xác thực đơn hàng\nTên bot, slot và tên ý định được trích xuất từ đối tượng sự kiện. Hàm validate_order được gọi để xác thực đầu vào của người dùng (chứa trong slots). def lambda_handler(event, context): print(event) bot = event[\u0026#39;bot\u0026#39;][\u0026#39;name\u0026#39;] slots = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;slots\u0026#39;] intent = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;name\u0026#39;] order_validation_result = validate_order(slots) 4.2 Xử lý phản hồi cho DialogCodeHook\nNếu nguồn của việc gọi là DialogCodeHook, có nghĩa là chatbot vẫn đang thu thập thông tin, nó sẽ: Nhắc người dùng sửa một slot không hợp lệ. Ủy quyền điều khiển cho bước tiếp theo nếu mọi thứ đều hợp lệ. #Handling the Response for DialogCodeHook if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;DialogCodeHook\u0026#39;: if not order_validation_result[\u0026#39;isValid\u0026#39;]: if \u0026#39;message\u0026#39; in order_validation_result: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;slotToElicit\u0026#34;: order_validation_result[\u0026#39;invalidSlot\u0026#39;], \u0026#34;type\u0026#34;: \u0026#34;ElicitSlot\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;PlainText\u0026#34;, \u0026#34;content\u0026#34;: order_validation_result[\u0026#39;message\u0026#39;] } ] } else: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;slotToElicit\u0026#34;: order_validation_result[\u0026#39;invalidSlot\u0026#39;], \u0026#34;type\u0026#34;: \u0026#34;ElicitSlot\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots } } } else: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Delegate\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#39;name\u0026#39;: intent, \u0026#39;slots\u0026#39;: slots } } } 4.3 Xử lý FulfillmentCodeHook\nNếu nguồn của việc gọi là FulfillmentCodeHook, nó sẽ đóng tương tác và xác nhận rằng đơn hàng đã được đặt.\n#Handling FulfillmentCodeHook if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;FulfillmentCodeHook\u0026#39;: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Close\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots, \u0026#34;state\u0026#34;: \u0026#34;Fulfilled\u0026#34; } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;PlainText\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;I\u0026#39;ve placed your order.\u0026#34; } ] } Trả về phản hồi Cuối cùng, phản hồi được in ra để mục đích gỡ lỗi và trả về cho người gọi (chatbot hoặc người dùng). print(response) return response Sau khi thêm mã vào hàm Lambda, hãy nhấn Deploy để xây dựng. Task 2: Thêm hàm Lambda vào chatbot Quay lại chatbot FriedChickenFriend_Sample. Chọn ý định OrderFriedChicken. Cuộn xuống Code hooks, chọn Use a Lambda function for initialization and validation. Cuộn lên Confirmation, chọn Advanced options. Cuộn xuống Dialog code hook, chọn Invoke Lambda function, đảm bảo chế độ Active được bật.\nNhấn Update options. Cuộn xuống Fulfillment, chọn Advanced options. Chọn Use a Lambda function for fulfillment.\nNhấn Update options. Nhấn Build và Test.\nChọn Setting trong chatbot.\nTrong Source, chọn hàm FriedChickenOrder.\nNhấn Save. Tiếp theo, tôi sẽ kiểm tra chatbot với một số tin nhắn như hình dưới đây.\nNhìn vào Summary, các giá trị đầu vào mà tôi đã nhập là medium, KFC, original đã được thêm vào cột Elicitation tương ứng với từng slot.\nKhi tôi chọn smoky BBQ từ KFC, bot đã nhận thấy có điều gì đó sai và từ chối yêu cầu của tôi, điều này thể hiện ứng dụng của hàm Lambda. Khi tôi trả lời Yes, bot phản hồi với I've placed your order, điều này khác với thông điệp đã được thiết lập trong Fulfillment ban đầu. Tôi đã làm điều này để có thể thấy rằng quá trình đã được thực hiện bởi Lambda.\nToàn bộ code cho Lambda function: import json friedChickenSizes = [\u0026#39;small\u0026#39;, \u0026#39;medium\u0026#39;, \u0026#39;large\u0026#39;, \u0026#39;family size\u0026#39;] friedChicken_branch = [\u0026#39;kfc\u0026#39;, \u0026#39;jollipee\u0026#39;, \u0026#39;texas\u0026#39;] kfc_types = [\u0026#39;original\u0026#39;, \u0026#39;extra crispy\u0026#39;, \u0026#39;hot \u0026amp; spicy\u0026#39;] jollipee_types = [\u0026#39;classic\u0026#39;, \u0026#39;spicy\u0026#39;, \u0026#39;sweet chili\u0026#39;] texas_types = [\u0026#39;smoky bbq\u0026#39;, \u0026#39;cajun spice\u0026#39;, \u0026#39;honey butter\u0026#39;] def validate_order(slots): # Validate FriedChickenSizes if \u0026#39;FriedChickenSizes\u0026#39; not in slots or not slots[\u0026#39;FriedChickenSizes\u0026#39;]: print(\u0026#39;Validating FriedChickenSizes Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChickenSizes\u0026#39; } if slots[\u0026#39;FriedChickenSizes\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in friedChickenSizes: print(\u0026#39;Invalid FriedChickenSizes\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChickenSizes\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a {} burger size.\u0026#39;.format(\u0026#34;, \u0026#34;.join(friedChickenSizes)) } # Validate FriedChicken_branch if \u0026#39;FriedChicken_branch\u0026#39; not in slots or not slots[\u0026#39;FriedChicken_branch\u0026#39;]: print(\u0026#39;Validating FriedChicken_branch Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_branch\u0026#39; } if slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in friedChicken_branch: print(\u0026#39;Invalid FriedChicken_branch\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_branch\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select from {} burger franchises.\u0026#39;.format(\u0026#34;, \u0026#34;.join(friedChicken_branch)) } # Validate FriedChicken_Types if \u0026#39;FriedChicken_Types\u0026#39; not in slots or not slots[\u0026#39;FriedChicken_Types\u0026#39;]: print(\u0026#39;Validating FriedChicken_Types Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39; } # Validate FriedChicken_Types for FriedChicken_branch branch_value = slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() type_value = slots[\u0026#39;FriedChicken_Types\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() if branch_value == \u0026#39;kfc\u0026#39;: if type_value not in kfc_types: print(\u0026#39;Invalid FriedChicken_Types for KFC\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a KFC type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(kfc_types)) } elif branch_value == \u0026#39;jollipee\u0026#39;: if type_value not in jollipee_types: print(\u0026#39;Invalid FriedChicken_Types for Jollipee\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a Jollipee type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(jollipee_types)) } elif branch_value == \u0026#39;texas\u0026#39;: if type_value not in texas_types: print(\u0026#39;Invalid FriedChicken_Types for Texas\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a Texas type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(texas_types)) } # Valid Order return {\u0026#39;isValid\u0026#39;: True} def lambda_handler(event, context): print(event) bot = event[\u0026#39;bot\u0026#39;][\u0026#39;name\u0026#39;] slots = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;slots\u0026#39;] intent = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;name\u0026#39;] order_validation_result = validate_order(slots) if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;DialogCodeHook\u0026#39;: if not order_validation_result[\u0026#39;isValid\u0026#39;]: if \u0026#39;message\u0026#39; in order_validation_result: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;slotToElicit\u0026#34;: order_validation_result[\u0026#39;invalidSlot\u0026#39;], \u0026#34;type\u0026#34;: \u0026#34;ElicitSlot\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;PlainText\u0026#34;, \u0026#34;content\u0026#34;: order_validation_result[\u0026#39;message\u0026#39;] } ] } else: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;slotToElicit\u0026#34;: order_validation_result[\u0026#39;invalidSlot\u0026#39;], \u0026#34;type\u0026#34;: \u0026#34;ElicitSlot\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots } } } else: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Delegate\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#39;name\u0026#39;: intent, \u0026#39;slots\u0026#39;: slots } } } if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;FulfillmentCodeHook\u0026#39;: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Close\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots, \u0026#34;state\u0026#34;: \u0026#34;Fulfilled\u0026#34; } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;PlainText\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;I\u0026#39;ve placed your order.\u0026#34; } ] } print(response) return response "
},
{
	"uri": "http://Khoadora.github.io/vi/2-build-a-chatbot/",
	"title": "Tạo ChatBot để đặt Gà Rán",
	"tags": [],
	"description": "",
	"content": " Vui lòng tạo bot của bạn bằng ngôn ngữ English (US). Workshop này sử dụng tính năng Context Carryover của Amazon Lex, chỉ khả dụng trong ngôn ngữ đó.\nBot demo này sẽ tạo một chatbot đơn giản để đặt gà rán, cung cấp một số tính năng đặt hàng cơ bản, như chọn kích cỡ, chi nhánh và loại gà của từng chi nhánh, món ăn kèm và đồ uống. Phần này sẽ hướng dẫn bạn cách khởi tạo và cấu hình bot, xây dựng các intent và loại slot cho từng intent.\nSau đây là bảng tóm tắt tất cả các loại Intent và Slot mà chúng ta sẽ tạo trong phần này: Nội dung Tạo bot và Cấu hình Tạo Intent và Loại Slot "
},
{
	"uri": "http://Khoadora.github.io/vi/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.2.-create-intent-friedchickenorder-and-slot-type-friedchickensize/",
	"title": "Tạo intent FriedChickenOrder và Slot types FriedChickenSize",
	"tags": [],
	"description": "",
	"content": "Nhiệm vụ 1: Tạo intent FriedChickenOrder Tại Intent name, nhập FriedChickenOrder.\nTại Sample utterances, nhập vào Add utterance là I'd like to order Fried Chicken, I want to order Fried Chicken, Fried Chicken.\nTại Initial response, nhập vào message là Okey, I can help you order a Fried Chicken.\nNhấn Save intent. Nhiệm vụ 2: Tạo Slot types FriedChickenSize Quay lại danh sách intents. Nhấn Slot types. Nhấn Add slot type - Add blank slot type.\nNhập tên slot type là FriedChickenSizes.\nTại Slot value resolution, chọn Expand values (default). Tại Slot type values, nhập các giá trị là Small, Medium, Large, Family Size. Nhấn Save Slot type.\nNhiệm vụ 3: Thêm Slot types FriedChickenSize vào intent FriedChickenOrder Tiếp theo, quay lại danh sách intents, chọn intent có tên FriedChickenOrder. Cuộn xuống Slots - Add slot.\nTại slot type, chọn FriedChickenSizes. Tại Name, nhập FriedChickenSize. Tại Prompts, nhập Which size fried chicken would you like (small, medium, larger, family size)?. Nhấn Add.\nCuộn xuống Closing response. Trong message, tôi sẽ viết Okay, You'd like a {FriedChickenSizes} fried chicken.. Sau đó, tôi sẽ tiếp tục hỏi Where would you like to order from (KFC, Jollibee or Texas)?.\n{FriedChickenSizes} sẽ là giá trị mà người dùng chọn từ Slots.\nNhấn Save intent và Build. Sau khi build, nhấn Test và nhập các tin nhắn để kiểm tra như bên dưới.\n"
},
{
	"uri": "http://Khoadora.github.io/vi/2-build-a-chatbot/2.2-create-intent-and-slot-types/",
	"title": "Tạo Intent và Loại Slot",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ tạo các Intent và Slot types, với tổng cộng 8 intent và 6 slot types. Các intent và slot được mô tả dưới đây.\nNội dung Tạo intent chào hỏi (greeting) Tạo intent FriedChickenOrder và Slot types FriedChickenSize Tạo intent KFC_branch và Slot types KFC_types Tạo intent Jollipee_branch và Slot types Jollipee_types Tạo intent Texas_branch và Slot types Texas_types Tạo intent SideOrder và Slot types Side_types Tạo intent DrinkOrder và Slot types Drink_types Cấu hình intent FallbackIntent "
},
{
	"uri": "http://Khoadora.github.io/vi/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.3.-create-intent-kfc_branch-and-slot-types-kfc_types/",
	"title": "Tạo intent KFC_branch và Slot types KFC_types",
	"tags": [],
	"description": "",
	"content": "Nhiệm vụ 1: Tạo intent KFC_branch Tại Intent name, nhập KFC_branch.\nTại Sample utterances, nhập vào Add utterance là KFC.\nTại Initial response, nhập vào message là Okay, you would like KFC fried chicken.\nNhấn Save intent và quay lại danh sách intents. Nhiệm vụ 2: Tạo Slot types KFC_types Quay lại danh sách intents. Nhấn Slot types. Nhấn Add slot type - Add blank slot type.\nNhập tên slot type là KFC_types.\nTại Slot value resolution, chọn Expand values (default). Tại Slot type values, nhập các giá trị là Original Recipe, Extra Crispy, Hot \u0026amp; Spicy. Nhấn Save Slot type.\nNhiệm vụ 3: Thêm Slot types KFC_types vào intent KFC_branch Tiếp theo, quay lại danh sách intents, chọn intent có tên KFC_branch.\nCuộn xuống Slots - Add slot.\nTại slot type, chọn KFC_types.\nTại Name, nhập KFC_types.\nTại Prompts, nhập Which KFC fried chicken would you like (Original Recipe, Extra Crispy, Hot \u0026amp; Spicy)?.\nNhấn Add.\nCuộn xuống Confirmation. Trong confirmation prompt, tôi sẽ viết Nice! Would you like me to order your {KFC_types}?.\n{KFC_types} sẽ là giá trị mà người dùng chọn từ Slots.\nTrong trường hợp người dùng trả lời No, tôi sẽ thiết lập Decline response để bot trả lời là Bummer! Stay hungry, my friend.\n*\nCuộn xuống Fulfillment. Tôi sẽ thông báo cho người dùng trạng thái khi hoàn thành tại On successful fulfillment là Okay, your order is on its way. Would you like to order another fried chicken, a side, or a drink?\nTrong trường hợp lỗi sẽ là Oh no! Something went wrong. Please try again.\n*\nNhấn Save intent và Build.\nSau khi build, nhấn Test và nhập các tin nhắn để kiểm tra như bên dưới.\n"
},
{
	"uri": "http://Khoadora.github.io/vi/3-validate-slot-data-with-lambda/",
	"title": "Xác thực dữ liệu Slot với Lambda",
	"tags": [],
	"description": "",
	"content": " Trong phần này, chúng ta sẽ xác thực dữ liệu Slot bằng Lambda, để khi người dùng chọn giá trị sai, chatbot sẽ yêu cầu chọn lại giá trị đúng. Tôi nhận thấy chatbot ở phần 2 có menu khá đầy đủ (bao gồm cả món ăn kèm và đồ uống), tuy nhiên, để đơn giản hóa việc lập trình hàm Lambda cho bạn và tôi, tôi sẽ xây dựng lại một chatbot đơn giản hơn với mục đích đặt gà rán trong phần 3.1. Nội dung Xây dựng lại chatbot đơn giản hơn Sử dụng các hàm Lambda cho chatbot "
},
{
	"uri": "http://Khoadora.github.io/vi/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.4.-create-intent-jollipee_branch-and-slot-types-jollipee_types/",
	"title": "Tạo intent Jollipee_branch và Slot types Jollipee_types",
	"tags": [],
	"description": "",
	"content": "Nhiệm vụ 1: Tạo intent Jollipee_branch Tại Intent name, nhập Jollipee_branch.\nTại Sample utterances, nhập vào Add utterance là Jollipee.\nTại Initial response, nhập vào message là Okey, You would like Jollipee fried chicken.\nNhấn Save intent và quay lại danh sách intents. Nhiệm vụ 2: Tạo Slot types Jollipee_types cho intent Jollipee_branch Nhấn Slot types. Nhấn Add slot type - Add blank slot type.\nNhập tên slot type là Jollipee_types.\nTại Slot value resolution, chọn Expand values (default). Tại Slot type values, nhập các giá trị là Classic, Spicy, Sweet Chili. Nhấn Save Slot type.\nNhiệm vụ 3: Thêm Slot types Jollipee_types vào intent Jollipee_branch Tiếp theo, quay lại danh sách intents, chọn intent có tên Jollipee_branch.\nCuộn xuống Slots - Add slot.\nTại slot type, chọn Jollipee_types.\nTại Name, nhập Jollipee_types.\nTại Prompts, nhập Which Jollipee fried chicken would you like (Classic, Spicy, Sweet Chili)?.\nNhấn Add.\nCuộn xuống Confirmation. Trong confirmation prompt, tôi sẽ viết Nice! Would you like me to order your {Jollipee_types}?.\nTrong trường hợp người dùng trả lời No, tôi sẽ thiết lập Decline response để bot trả lời là Bummer! Stay hungry, my friend.\n*\nCuộn xuống Fulfillment. Tôi sẽ thông báo cho người dùng trạng thái khi hoàn thành tại On successful fulfillment là Okay, your order is on its way. Would you like to order another fried chicken, a side, or a drink?.\nTrong trường hợp lỗi sẽ là Oh no! Something went wrong. Please try again.\nNhấn Save intent và Build.\nSau khi build, nhấn Test và nhập các tin nhắn để kiểm tra như bên dưới.\n"
},
{
	"uri": "http://Khoadora.github.io/vi/4-integrate-chatbot-into-a-web-page/",
	"title": "Tích hợp ChatBot vào Trang Web",
	"tags": [],
	"description": "",
	"content": " Ở đây chúng ta sẽ tích hợp chatbot FriedChickenFriend_Simple vào một trang web. Tôi đặt mã trang web của mình ở cuối trang, bạn có thể kéo xuống cuối để xem hoặc theo liên kết để tham khảo: Code trang web Nội dung:\nThêm Amazon Lex vào ứng dụng Kommunicate. Thêm chatbot vào trang web. Task 1: Thêm Amazon Lex vào ứng dụng Kommunicate Truy cập Trang web Kommunicate.\nNhấn Try for free và đăng nhập bằng email sinh viên hoặc email công việc của bạn để sử dụng miễn phí. Đây là giao diện ứng dụng sau khi đăng nhập, chọn Bot Integration. Nhấn integration bot ở Amazon Lex. Sau khi chọn, ứng dụng sẽ có một giao diện như hình dưới đây, tôi sẽ chỉ cho bạn cách lấy Access key ID và Secret access key. Truy cập AWS IAM console.\nNhấn User groups - Create group. Nhập User group name là LexAdmins.\nTrong Add users to the group, chọn một người dùng đã có.\nTrong Attach permissions policies, tìm kiếm lex và chọn AmazonLexFullAccess.\nNhấn Create user group. Quay lại IAM console, chọn User - Nhấn vào tên người dùng đã tạo trước đó, tên người dùng của tôi là khoa. Chọn Security credentials, cuộn xuống Access keys và chọn Create access key. Đối với Use case, chọn Other. Nhấn Next. Trong Description tag value, nhập access Konmunicate. Nhấn Create access key. Sau khi hoàn tất, bạn sẽ thấy Access key và Secret access key hiển thị, sao chép để lưu lại và chọn Done. Quay lại ứng dụng Kommunicate, sao chép Access key ID và Secret access key từ ghi chú và điền vào.\nTrong Region, chọn US East.\nTrong Bot name in Lex platform, chọn FriedChickenFriend_Simple.\nTrong Bot alias, chọn TestBotAlias.\nTrong Default bot language, chọn English (US).\nNhấn Save and proceed. Sử dụng tên bot và avatar theo mong muốn, ở đây tôi để mặc định. Chọn Disable this feature, sau đó nhấn Finish bot setup. Khi hoàn tất, nhấn Try out your new bot, FriedChickenFriend_Simple. Ứng dụng sẽ đưa chúng ta đến một trang web khác, ở đây chúng ta có thể thấy bot FriedChickenFriend_Simple của mình.\nTôi sẽ thử một số tin nhắn như hình dưới đây. Task 2: Thêm chatbot vào trang web Dưới đây là giao diện trang web mà tôi đã tạo, bạn có thể lấy mã trang web qua liên kết: Bây giờ, quay lại ứng dụng Kommunicate, chọn Setting.\nChọn Install, sao chép mã để thêm vào tệp HTML. Dán mã đã sao chép vào thẻ head và khởi động lại trang web. Chúng ta có thể thấy biểu tượng chatbot đã được thêm vào trang web. Bây giờ tôi sẽ thử một số tin nhắn để kiểm tra và hoàn thành phần này. Toàn bộ code của trang web, được chạy bằng file html: \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Fried Chicken Menu\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;img/favicon.ico\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; /* Reset margin and padding */ * { margin: 0; padding: 0; box-sizing: border-box; } /* Body settings */ body { font-family: \u0026#39;Arial\u0026#39;, sans-serif; background-color: #f8f9fa; color: #343a40; display: flex; flex-direction: column; height: 100vh; } /* Header settings */ header { background-color: #d62828; color: white; padding: 20px 0; text-align: center; flex: 0 1 15%; /* Occupy 15% of the screen height */ } header h1 { font-size: 2.5rem; } /* Navigation menu */ nav { display: flex; justify-content: center; background-color: #003049; padding: 10px 0; margin-bottom: 20px; } nav ul { list-style: none; display: flex; gap: 20px; } nav ul li { color: white; font-size: 1.2rem; cursor: pointer; transition: color 0.3s; } nav ul li:hover { color: #ffc300; } /* Main content */ main { flex: 1; /* Occupy remaining space */ display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; } /* Section for each menu */ section { background-color: white; border-radius: 10px; padding: 20px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); width: 80%; max-width: 800px; margin-bottom: 20px; } section h2, section h3 { color: #003049; margin-bottom: 15px; } /* Horizontal menu styling */ section ul { list-style: none; padding-left: 0; display: flex; justify-content: space-around; } section ul li { display: flex; flex-direction: column; align-items: center; background-color: #f1f1f1; margin: 10px; padding: 10px; border-radius: 8px; transition: background-color 0.3s ease; text-align: center; } section ul li:hover { background-color: #f7c59f; } /* Footer settings */ footer { background-color: #003049; color: white; text-align: center; padding: 10px 0; flex: 0 1 10%; /* Occupy 10% of the screen height */ } footer a { color: #ffc300; text-decoration: none; } footer a:hover { text-decoration: underline; } \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; (function(d, m){ var kommunicateSettings = {\u0026#34;appId\u0026#34;:\u0026#34;35a6190fee5ad6aba7d62941d9d0c952d\u0026#34;,\u0026#34;popupWidget\u0026#34;:true,\u0026#34;automaticChatOpenOnNavigation\u0026#34;:true}; var s = document.createElement(\u0026#34;script\u0026#34;); s.type = \u0026#34;text/javascript\u0026#34;; s.async = true; s.src = \u0026#34;https://widget.kommunicate.io/v2/kommunicate.app\u0026#34;; var h = document.getElementsByTagName(\u0026#34;head\u0026#34;)[0]; h.appendChild(s); window.kommunicate = m; m._globals = kommunicateSettings; })(document, window.kommunicate || {}); /* NOTE : Use web server to view HTML files as real-time update will not work if you directly open the HTML file in the browser. */ \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Fried Chicken Menu\u0026lt;/h1\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;!-- Navigation menu --\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Home\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Menu\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Contact\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;About\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;main\u0026gt; \u0026lt;!-- KFC Menu --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h2\u0026gt;KFC Fried Chicken\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Original Recipe\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Extra Crispy\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Hot \u0026amp; Spicy\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- Jollibee Menu --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h2\u0026gt;Jollibee Fried Chicken\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Classic\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Spicy\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Sweet Chili\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- Texas Menu --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h2\u0026gt;Texas Fried Chicken\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Smoky BBQ\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Cajun Spice\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Honey Butter\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- Chicken Sizes --\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h3\u0026gt;Chicken Sizes (# pieces)\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Small\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Medium\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Large\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Family Size\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;p\u0026gt;\u0026amp;copy; 2024 Fried Chicken Menu\u0026lt;/p\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; "
},
{
	"uri": "http://Khoadora.github.io/vi/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.5.-create-intent-texas_branch-and-slot-types-texas_types/",
	"title": "Tạo intent Texas_branch và Slot types Texas_types",
	"tags": [],
	"description": "",
	"content": "Nhiệm vụ 1: Tạo intent Texas_branch Tại Intent name, nhập Texas_branch.\nTại Sample utterances, nhập vào Add utterance là Texas.\nTại Initial response, nhập vào message là Okey, You would like Texas fried chicken.\nNhấn Save intent và quay lại danh sách intents. Nhiệm vụ 2: Tạo Slot types Texas_types cho intent Texas_branch Nhấn Slot types. Nhấn Add slot type - Add blank slot type.\nNhập tên slot type là Texas_types.\nTại Slot value resolution, chọn Expand values (default). Tại Slot type values, nhập các giá trị là Smoky BBQ, Cajun Spice, Honey Butter. Nhấn Save Slot type.\nNhiệm vụ 3: Thêm Slot types Texas_types vào intent Texas_branch Tiếp theo, quay lại danh sách intents, chọn intent có tên Texas_branch.\nCuộn xuống Slots - Add slot.\nTại slot type, chọn Texas_types.\nTại Name, nhập Texas_types.\nTại Prompts, nhập Which Texas fried chicken would you like (Smoky BBQ, Cajun Spice, Honey Butter)?.\nNhấn Add.\nCuộn xuống Confirmation. Trong confirmation prompt, tôi sẽ viết Nice! Would you like me to order your {Texas_types}?.\n{Texas_types} sẽ là giá trị mà người dùng chọn từ Slots.\nTrong trường hợp người dùng trả lời No, tôi sẽ thiết lập Decline response để bot trả lời là Bummer! Stay hungry, my friend.\n*\nCuộn xuống Fulfillment. Tôi sẽ thông báo cho người dùng trạng thái khi hoàn thành tại On successful fulfillment là Okay, your order is on its way. Would you like to order another fried chicken, a side, or a drink?.\nIn case of failure sẽ là Oh no! Something went wrong. Please try again.\n*\nNhấn Save intent và Build.\nSau khi build, nhấn Test và nhập các tin nhắn để kiểm tra như bên dưới.\n"
},
{
	"uri": "http://Khoadora.github.io/vi/5-add-response-cards/",
	"title": "Thêm Response Cards",
	"tags": [],
	"description": "",
	"content": " Ở đây chúng ta sẽ thêm Response Cards vào chatbot FriedChickenFriend_Simple. Tôi đặt mã trình xử lý Lambda cho thẻ phản hồi ở cuối trang, bạn có thể cuộn xuống cuối để xem hoặc theo liên kết để tham khảo: Code hàm Lambda cho response card Nội dung:\nCấu hình Response Cards vào chatbot. Lập trình Lambda handler cho response card. Cấu hình tích hợp Response Card cho Lambda. Task 1: Cấu hình Response Cards vào chatbot Bước 1: Thêm response card cho slot FriedChickenSizes Truy cập Amazon Lex console.\nChọn bot FriedChickenFriend_Simple. Đi tới intents, chọn intent OrderFriedChicken. Cuộn xuống Slots, chọn slot FriedChickenSizes, nhấn Advanced options. Cuộn xuống Slot prompts, chọn More prompt options. Cuộn xuống Slot prompts, chọn Add - Add card group. Trong Card group, nhập Title là FriedChickenFriend_Simple.\nTrong Subtitle, nhập What size fried chicken would you like?.\nỞ phần Buttons, thêm 4 kích thước: small, medium, large, family size.\nNhấn Update prompts. Nhấn Update slot. Khi hoàn tất, nhấn Build và Test. Kết quả sẽ như hình dưới đây. Bước 2: Thêm response card cho slot FriedChicken_branch Cuộn xuống Slots, chọn slot FriedChicken_branch, nhấn Advanced options. Cuộn xuống Slot prompts, chọn More prompt options.\nCuộn xuống Slot prompts, chọn Add - Add card group. Trong Card group, nhập Title là FriedChickenFriend_Simple.\nTrong Subtitle, nhập Where would you like to order your fried chicken from?.\nỞ phần Buttons, thêm 3 chi nhánh: KFC, Jollibee và Texas.\nNhấn Update prompts. Nhấn Update slot. Khi hoàn tất, nhấn Build và Test. Kết quả sẽ như hình dưới đây. Bước 3: Thêm response card cho slot FriedChicken_Types Cuộn xuống Slots, chọn slot FriedChicken_Types, nhấn Advanced options. Cuộn xuống Slot prompts, chọn More prompt options.\nCuộn xuống Slot prompts, chọn Add - Add card group. Trong Card group, nhập Title là FriedChickenFriend_Types.\nTrong Subtitle, nhập What type of fried chicken would you like?.\nỞ phần Buttons, thêm 5 loại: Original Recipe, Extra Crispy, Hot \u0026amp; Spicy, Jollibee Fried Chicken, Classic Spicy. 5 buttons là tối đa.\nNhấn Update prompts. Nhấn Update slot. Khi hoàn tất, nhấn Build và Test. Kết quả sẽ như hình dưới đây. Bạn có thể quay lại trang web để xem, Response card cũng đã được thêm vào chatbot trên web. Task 2: Lập trình Lambda handler cho response card Trong phần mã Lambda handler cho response card, tôi chỉ thay đổi hàm lambda_handler trong mã ở phần 3.2, các hàm còn lại không có thay đổi. Các thay đổi như sau: Dưới đây là Đoạn 2 đã được thay thế hình ảnh bằng đoạn code tương ứng từ Đoạn 1:\nĐoạn 2:\nTrích xuất thông tin từ sự kiện và xác thực đơn hàng: Tên bot, slot và tên intent được trích xuất từ đối tượng sự kiện. Hàm validate_order được gọi để xác thực đầu vào của người dùng (có trong slots). def lambda_handler(event, context): print(event) bot = event[\u0026#39;bot\u0026#39;][\u0026#39;name\u0026#39;] slots = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;slots\u0026#39;] intent = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;name\u0026#39;] order_validation_result = validate_order(slots) print(order_validation_result) Xử lý Dialog Code Hook và xử lý lỗi xác thực: if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;DialogCodeHook\u0026#39;: if not order_validation_result[\u0026#39;isValid\u0026#39;]: Chuẩn bị thông điệp phản hồi: if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;DialogCodeHook\u0026#39;: if not order_validation_result[\u0026#39;isValid\u0026#39;]: response_message = \u0026#39;FriedChickenFriend\u0026#39; if \u0026#39;message\u0026#39; in order_validation_result: response_message = order_validation_result[\u0026#39;message\u0026#39;] response_card_sub_title = \u0026#39;\u0026#39; response_card_buttons = [] Thiết lập Response Card:\n4.1 Tạo tiêu đề và nút cho chi nhánh:\nkfc_sub_title = \u0026#39;Please select a Fried Chicken type\u0026#39; kfc_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Original\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;original\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Extra Crispy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;extra crispy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Hot \u0026amp; Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;hot \u0026amp; spicy\u0026#34; } ] jollipee_sub_title = \u0026#39;Please select a Jollipee type\u0026#39; jollipee_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Classic\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;classic\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;spicy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Sweet Chili\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;sweet chili\u0026#34; } ] texas_sub_title = \u0026#39;Please select a Texas type\u0026#39; texas_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Smoky BBQ\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;smoky bbq\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Cajun Spice\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cajun spice\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Honey Butter\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;honey butter\u0026#34; } ] 4.2 Xử lý trường hợp khi slot \u0026ldquo;FriedChickenSizes\u0026rdquo; không hợp lệ:\nMột tiêu đề yêu cầu người dùng chọn kích thước gà rán. Các nút cho các kích thước khác nhau (Small, Medium, Large, Family Size) mà người dùng có thể chọn để chỉnh sửa đầu vào. if order_validation_result[\u0026#39;invalidSlot\u0026#39;] == \u0026#34;FriedChickenSizes\u0026#34;: response_card_sub_title = \u0026#34;Please select a Fried Chicken size\u0026#34; response_card_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Small\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;small\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Medium\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;medium\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Large\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;large\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Family Size\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;family size\u0026#34; } ] 4.3 Xử lý tình huống khi slot \u0026ldquo;FriedChicken_branch\u0026rdquo; không hợp lệ:\nMột tiêu đề hướng dẫn người dùng chọn chuỗi gà rán. Các nút cho ba chuỗi: KFC, Jollibee và Texas. Mỗi nút có nhãn và giá trị sẽ được gửi lại khi người dùng chọn. if order_validation_result[\u0026#39;invalidSlot\u0026#39;] == \u0026#34;FriedChicken_branch\u0026#34;: response_card_sub_title = \u0026#34;Please select a Fried Chicken franchise\u0026#34; response_card_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;KFC\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;kfc\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Jollipee\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;jollipee\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Texas\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;texas\u0026#34; } ] 4.4 Xử lý tình huống khi slot \u0026ldquo;FriedChicken_Types\u0026rdquo; không hợp lệ:\nif order_validation_result[\u0026#39;invalidSlot\u0026#39;] == \u0026#34;FriedChicken_Types\u0026#34;: if order_validation_result[\u0026#39;invalidFranchise\u0026#39;] == \u0026#34;kfc\u0026#34;: response_card_sub_title = kfc_sub_title response_card_buttons = kfc_buttons elif order_validation_result[\u0026#39;invalidFranchise\u0026#39;] == \u0026#34;jollipee\u0026#34;: response_card_sub_title = jollipee_sub_title response_card_buttons = jollipee_buttons elif order_validation_result[\u0026#39;invalidFranchise\u0026#39;] == \u0026#34;texas\u0026#34;: response_card_sub_title = texas_sub_title response_card_buttons = texas_buttons else: response_card_sub_title = \u0026#39;Please select a fried chicken type\u0026#39; response_card_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Original\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;original\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Extra Crispy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;extra crispy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Hot \u0026amp; Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;hot \u0026amp; spicy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Classic\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;classic\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;spicy\u0026#34; } ] Tạo phản hồi: Xây dựng một phản hồi yêu cầu người dùng cung cấp giá trị slot đúng, hiển thị một card phản hồi hình ảnh với các nút để chọn tùy chọn dựa trên slot không hợp lệ. response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;slotToElicit\u0026#34;: order_validation_result[\u0026#39;invalidSlot\u0026#39;], \u0026#34;type\u0026#34;: \u0026#34;ElicitSlot\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots, } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;ImageResponseCard\u0026#34;, \u0026#34;content\u0026#34;: response_message, \u0026#34;imageResponseCard\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;FriedChickenFriend\u0026#34;, \u0026#34;subtitle\u0026#34;: response_card_sub_title, \u0026#34;buttons\u0026#34;: response_card_buttons } } ] } Ủy quyền cho Lex: Nếu đơn hàng hợp lệ, khối này tạo phản hồi để ủy quyền xử lý lại cho Lex để tiếp tục xử lý cuộc hội thoại. else: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Delegate\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#39;name\u0026#39;: intent, \u0026#39;slots\u0026#39;: slots } } } Tạo phản hồi hoàn tất: Xây dựng một phản hồi để chỉ ra rằng đơn hàng đã được đặt thành công và đóng cuộc hội thoại với Lex. Thông điệp \u0026ldquo;I\u0026rsquo;ve placed your order.\u0026rdquo; được gửi cho người dùng. if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;FulfillmentCodeHook\u0026#39;: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Close\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots, \u0026#34;state\u0026#34;: \u0026#34;Fulfilled\u0026#34; } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;PlainText\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;I\u0026#39;ve placed your order.\u0026#34; } ] } print(response) return response Task 3: Cấu hình tích hợp Response Card cho Lambda. Sao chép mã và dán vào hàm lambda, nhấn Deploy. Đi tới Intent: OrderFriedChicken, nhấn Build và Test. Bạn có thể thấy khi tôi chọn loại không đúng của Jollibee, chatbot đã yêu cầu tôi chọn lại, đó là ứng dụng của Response Card trong hàm Lambda.\nToàn bộ code Lambda handler for response card: import json friedChickenSizes = [\u0026#39;small\u0026#39;, \u0026#39;medium\u0026#39;, \u0026#39;large\u0026#39;, \u0026#39;family size\u0026#39;] friedChicken_branch = [\u0026#39;kfc\u0026#39;, \u0026#39;jollipee\u0026#39;, \u0026#39;texas\u0026#39;] kfc_types = [\u0026#39;original\u0026#39;, \u0026#39;extra crispy\u0026#39;, \u0026#39;hot \u0026amp; spicy\u0026#39;] jollipee_types = [\u0026#39;classic\u0026#39;, \u0026#39;spicy\u0026#39;, \u0026#39;sweet chili\u0026#39;] texas_types = [\u0026#39;smoky bbq\u0026#39;, \u0026#39;cajun spice\u0026#39;, \u0026#39;honey butter\u0026#39;] def validate_order(slots): # Validate FriedChickenSizes if not slots[\u0026#39;FriedChickenSizes\u0026#39;]: print(\u0026#39;Validating FriedChickenSizes Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChickenSizes\u0026#39; } if slots[\u0026#39;FriedChickenSizes\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in friedChickenSizes: print(\u0026#39;Invalid FriedChickenSizes\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChickenSizes\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a {} fried chicken size.\u0026#39;.format(\u0026#34;, \u0026#34;.join(friedChickenSizes)) } # Validate FriedChicken_branch if not slots[\u0026#39;FriedChicken_branch\u0026#39;]: print(\u0026#39;Validating FriedChicken_branch Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_branch\u0026#39; } if slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in friedChicken_branch: print(\u0026#39;Invalid FriedChickenSizes\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_branch\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select from {} fried chicken branch.\u0026#39;.format(\u0026#34;, \u0026#34;.join(friedChicken_branch)) } # Validate FriedChicken_Types if not slots[\u0026#39;FriedChicken_Types\u0026#39;]: print(\u0026#39;Validating FriedChicken_Types Slot\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;invalidFranchise\u0026#39;: \u0026#39;\u0026#39; } # Validate FriedChicken_Types for FriedChicken_branch if slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() == \u0026#39;kfc\u0026#39;: if slots[\u0026#39;FriedChicken_Types\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in kfc_types: print(\u0026#39;Invalid FriedChicken_Types for KFC\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;invalidFranchise\u0026#39;: \u0026#39;kfc\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a KFC type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(kfc_types)) } if slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() == \u0026#39;jollipee\u0026#39;: if slots[\u0026#39;FriedChicken_Types\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in jollipee_types: print(\u0026#39;Invalid FriedChicken_Types for Jollipee\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;invalidFranchise\u0026#39;: \u0026#39;jollipee\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a Jollipee type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(jollipee_types)) } if slots[\u0026#39;FriedChicken_branch\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() == \u0026#39;texas\u0026#39;: if slots[\u0026#39;FriedChicken_Types\u0026#39;][\u0026#39;value\u0026#39;][\u0026#39;originalValue\u0026#39;].lower() not in texas_types: print(\u0026#39;Invalid FriedChicken_Types for Texas\u0026#39;) return { \u0026#39;isValid\u0026#39;: False, \u0026#39;invalidSlot\u0026#39;: \u0026#39;FriedChicken_Types\u0026#39;, \u0026#39;invalidFranchise\u0026#39;: \u0026#39;texas\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;Please select a Texas type of {}.\u0026#39;.format(\u0026#34;, \u0026#34;.join(texas_types)) } # Valid Order return {\u0026#39;isValid\u0026#39;: True} def lambda_handler(event, context): print(event) bot = event[\u0026#39;bot\u0026#39;][\u0026#39;name\u0026#39;] slots = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;slots\u0026#39;] intent = event[\u0026#39;sessionState\u0026#39;][\u0026#39;intent\u0026#39;][\u0026#39;name\u0026#39;] order_validation_result = validate_order(slots) print(order_validation_result) if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;DialogCodeHook\u0026#39;: if not order_validation_result[\u0026#39;isValid\u0026#39;]: response_message = \u0026#39;FriedChickenFriend\u0026#39; if \u0026#39;message\u0026#39; in order_validation_result: response_message = order_validation_result[\u0026#39;message\u0026#39;] response_card_sub_title = \u0026#39;\u0026#39; response_card_buttons = [] kfc_sub_title = \u0026#39;Please select a Fried Chicken type\u0026#39; kfc_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Original\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;original\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Extra Crispy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;extra crispy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Hot \u0026amp; Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;hot \u0026amp; spicy\u0026#34; } ] jollipee_sub_title = \u0026#39;Please select a Jollipee type\u0026#39; jollipee_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Classic\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;classic\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;spicy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Sweet Chili\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;sweet chili\u0026#34; } ] texas_sub_title = \u0026#39;Please select a Texas type\u0026#39; texas_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Smoky BBQ\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;smoky bbq\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Cajun Spice\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cajun spice\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Honey Butter\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;honey butter\u0026#34; } ] if order_validation_result[\u0026#39;invalidSlot\u0026#39;] == \u0026#34;FriedChickenSizes\u0026#34;: response_card_sub_title = \u0026#34;Please select a Fried Chicken size\u0026#34; response_card_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Small\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;small\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Medium\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;medium\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Large\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;large\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Family Size\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;family size\u0026#34; } ] if order_validation_result[\u0026#39;invalidSlot\u0026#39;] == \u0026#34;FriedChicken_branch\u0026#34;: response_card_sub_title = \u0026#34;Please select a Fried Chicken franchise\u0026#34; response_card_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;KFC\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;kfc\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Jollipee\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;jollipee\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Texas\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;texas\u0026#34; } ] if order_validation_result[\u0026#39;invalidSlot\u0026#39;] == \u0026#34;FriedChicken_Types\u0026#34;: if order_validation_result[\u0026#39;invalidFranchise\u0026#39;] == \u0026#34;kfc\u0026#34;: response_card_sub_title = kfc_sub_title response_card_buttons = kfc_buttons elif order_validation_result[\u0026#39;invalidFranchise\u0026#39;] == \u0026#34;jollipee\u0026#34;: response_card_sub_title = jollipee_sub_title response_card_buttons = jollipee_buttons elif order_validation_result[\u0026#39;invalidFranchise\u0026#39;] == \u0026#34;texas\u0026#34;: response_card_sub_title = texas_sub_title response_card_buttons = texas_buttons else: response_card_sub_title = \u0026#39;Please select a fried chicken type\u0026#39; response_card_buttons = [ { \u0026#34;text\u0026#34;: \u0026#34;Original\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;original\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Extra Crispy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;extra crispy\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Hot \u0026amp; Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;hot \u0026amp; spicy\u0026#34; } , { \u0026#34;text\u0026#34;: \u0026#34;Classic\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;classic\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Spicy\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;spicy\u0026#34; } ] response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;slotToElicit\u0026#34;: order_validation_result[\u0026#39;invalidSlot\u0026#39;], \u0026#34;type\u0026#34;: \u0026#34;ElicitSlot\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots, } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;ImageResponseCard\u0026#34;, \u0026#34;content\u0026#34;: response_message, \u0026#34;imageResponseCard\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;FriedChickenFriend\u0026#34;, \u0026#34;subtitle\u0026#34;: response_card_sub_title, \u0026#34;buttons\u0026#34;: response_card_buttons } } ] } else: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Delegate\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#39;name\u0026#39;: intent, \u0026#39;slots\u0026#39;: slots } } } if event[\u0026#39;invocationSource\u0026#39;] == \u0026#39;FulfillmentCodeHook\u0026#39;: response = { \u0026#34;sessionState\u0026#34;: { \u0026#34;dialogAction\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Close\u0026#34; }, \u0026#34;intent\u0026#34;: { \u0026#34;name\u0026#34;: intent, \u0026#34;slots\u0026#34;: slots, \u0026#34;state\u0026#34;: \u0026#34;Fulfilled\u0026#34; } }, \u0026#34;messages\u0026#34;: [ { \u0026#34;contentType\u0026#34;: \u0026#34;PlainText\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;I\u0026#39;ve placed your order.\u0026#34; } ] } print(response) return response "
},
{
	"uri": "http://Khoadora.github.io/vi/6-slack-integration/",
	"title": "Slack Integration",
	"tags": [],
	"description": "",
	"content": "Slack là một nền tảng giao tiếp nhóm phổ biến cho phép tích hợp nhiều ứng dụng để tự động hóa quy trình làm việc.\nTích hợp Amazon Lex vào Slack giúp tự động hóa giao tiếp, cải thiện trải nghiệm người dùng và tận dụng sức mạnh của hệ sinh thái AWS. Điều này cho phép người dùng Slack tương tác với các bot thông minh để xử lý yêu cầu một cách nhanh chóng và hiệu quả, từ hỗ trợ khách hàng đến quản lý nhiệm vụ.\nTruy cập Amazon Lex console.\nChọn bot FriedChickenFriend_Simple. Chọn Channel integrations - Add channel. Tại Platform, chọn Slack. Nhập tên là FriedChickenFriend.\nTại Alias, chọn TestBotAlias.\nLanguage chọn English (US). Truy cập Slack.\nNhấp Get started và đăng nhập bằng email sinh viên hoặc email công việc của bạn để sử dụng miễn phí. Nhập tên của bạn cho ứng dụng. Nhập tên của chatbot cho ứng dụng. Chọn Start with free. Đây là giao diện của không gian làm việc Slack. Sau khi không gian làm việc đã được khởi tạo, chuyển đến api.slack.com/apps.\nChọn Create an App. Chọn From scratch. Nhập App Name là FriedChickenFriend.\nPick a workspace to develop your app in, chọn Student.\nNhấp Create App. Sao chép Client ID, Client Secret và Verification Token để dán vào Amazon Lex. Chọn Interactivity and Shortcuts, bật On.\nTại Request URL, nhập https://slack.com.\nChọn Save changes. Quay lại phần Channel integrations trong Amazon Lex.\nNhập Client ID, Client Secret và Verification Token từ API Slack.\nNhấp Add. Chọn Channel name là FriedChickenFriend. Sao chép Endpoint và OAuth endpoint và ghi chú lại. Quay lại API Slack, chọn OAuth \u0026amp; Permissions. Trong Redirect URLs, dán OAuth endpoint từ Amazon Lex vào.\nNhấn Save URLs. Cuộn xuống Scopes, nhập Add scope là chat:write và team:read. Chọn Interactivity and Shortcuts, thay đổi Request URL thành Endpoint từ Amazon Lex.\nNhấn Save changes. Chọn Event Subscriptions, bật On.\nTại Request URL, nhập Endpoint từ Amazon Lex.\nAdd Bot User Event là message:im.\nNhấn Save changes. Chọn App Home. Cuộn xuống Show Tabs, đánh dấu chọn Allow users to send Slash commands and messages from the messages tab. Chọn Manage Distribution - Add to Slack. Chọn Allow. Chọn bot FriedChickenFriend và kiểm tra để hoàn tất.\n"
},
{
	"uri": "http://Khoadora.github.io/vi/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.6.-create-intent-sideorder-and-slot-types-side_types/",
	"title": "Tạo intent SideOrder và Slot types Side_types",
	"tags": [],
	"description": "",
	"content": "Nhiệm vụ 1: Tạo intent SideOrder Tại Intent name, nhập SideOrder.\nTại Sample utterances, nhập vào Add utterance là I want to order a side, Side, A side, Side order.\nTại Initial response, nhập vào message là Okey, You would like to order a side..\nNhấn Save intent và quay lại danh sách intents. Nhiệm vụ 2: Tạo Slot types Side_types cho intent SideOrder Nhấn Slot types. Nhấn Add slot type - Add blank slot type.\nNhập tên slot type là Side_types.\nTại Slot value resolution, chọn Expand values (default). Tại Slot type values, nhập các giá trị là Fries, Onion Rings, Tater Tots. Nhấn Save Slot type.\nNhiệm vụ 3: Thêm Slot types Side_types vào intent SideOrder Tiếp theo, quay lại danh sách intents, chọn intent có tên SideOrder.\nCuộn xuống Slots - Add slot.\nTại slot type, chọn Side_types.\nTại Name, nhập Side_types.\nTại Prompts, nhập Which side would you like (Fries, Onion Rings, or Tater Tots)?.\nNhấn Add.\nCuộn xuống Confirmation. Trong confirmation prompt, tôi sẽ viết Nice! Would you like me to order your {Side_types}?.\n{Side_types} sẽ là giá trị mà người dùng chọn từ Slots.\nTrong trường hợp người dùng trả lời No, tôi sẽ thiết lập Decline response để bot trả lời là Bummer! Stay hungry, my friend.\n*\nCuộn xuống Fulfillment. Tôi sẽ thông báo cho người dùng trạng thái khi hoàn thành tại On successful fulfillment là Okay, your order is on its way. Would you like to order another fried chicken, a side, or a drink?.\nIn case of failure sẽ là Oh no! Something went wrong. Please try again.\n*\nNhấn Save intent và Build.\nSau khi build, nhấn Test và nhập các tin nhắn để kiểm tra như bên dưới.\n"
},
{
	"uri": "http://Khoadora.github.io/vi/7-clear-up/",
	"title": "Dọn dẹp",
	"tags": [],
	"description": "",
	"content": "Tổng quan Chúng ta sẽ tiến hành xóa tất cả các tài nguyên có thể phát sinh chi phí đã được tạo trong Workshop Banker Bot:\nXóa FriedChickenFriend và FriedChickenFriend_Simple khỏi Amazon Lex Xóa hàm Lambda liên quan Xóa các tệp log của hàm Lambda Sau khi hoàn tất các bước này, sẽ không còn tài nguyên nào có thể phát sinh chi phí trong tài khoản của bạn.\nNhiệm vụ 1: Xóa FriedChickenFriend và FriedChickenFriend_Simple khỏi Amazon Lex Điều hướng trở lại bảng điều khiển Amazon Lex, và nhấn vào menu Bots ở thanh bên trái. Điều này sẽ hiển thị danh sách đầy đủ các bot mà bạn đã định nghĩa. Nhấn vào nút radio bên cạnh mục FriedChickenFriend và sau đó chọn Delete từ menu thả xuống Action. Nhập Delete để xác nhận.\nLàm tương tự với bot FriedChickenFriend_Simple\nNhiệm vụ 2: Xóa hàm Lambda Điều hướng đến bảng điều khiển AWS Lambda, và nhấn vào menu Functions ở thanh bên trái. Điều này sẽ hiển thị danh sách đầy đủ các hàm Lambda mà bạn đã định nghĩa. Nhấn vào nút radio bên cạnh mục BankingBotEnglish và chọn Delete từ menu thả xuống Action.\nNhập Delete để xác nhận.\nNhiệm vụ 3: Xóa các tệp log của hàm Lambda Điều hướng đến dịch vụ CloudWatch, sử dụng cùng phương pháp bạn đã dùng để điều hướng đến các trang dịch vụ khác, và nhấn vào Logs ở thanh bên trái, sau đó là mục con Log groups. Trong thanh tìm kiếm, gõ BankingBot để lọc danh sách các nhóm log, và bạn sẽ thấy nhóm log của hàm Lambda mà bạn vừa xóa. Nhấn vào hộp kiểm, sau đó chọn Delete log group(s) trong menu Actions. Nhập Delete để xác nhận.\n"
},
{
	"uri": "http://Khoadora.github.io/vi/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.7.-create-intent-drinkorder-and-slot-types-drink_types/",
	"title": "Tạo intent DrinkOrder và Slot types Drink_types",
	"tags": [],
	"description": "",
	"content": "Nhiệm vụ 1: Tạo intent DrinkOrder Tại Intent name, nhập DrinkOrder.\nTại Sample utterances, nhập vào Add utterance là I want to order a drink, Drink, A drink, drink order.\nTại Initial response, nhập vào message là Okey, You would like to order a drink..\nNhấn Save intent và quay lại danh sách intents. Nhiệm vụ 2: Tạo Slot types Drink_types cho intent DrinkOrder Nhấn Slot types. Nhấn Add slot type - Add blank slot type.\nNhập tên slot type là Drink_types.\nTại Slot value resolution, chọn Expand values (default). Tại Slot type values, nhập các giá trị là Soda, Beer, Coca. Nhấn Save Slot type.\nNhiệm vụ 3: Thêm Slot types Drink_types vào intent DrinkOrder Tiếp theo, quay lại danh sách intents, chọn intent có tên DrinkOrder.\nCuộn xuống Slots - Add slot.\nTại slot type, chọn Drink_types.\nTại Name, nhập Drink_types.\nTại Prompts, nhập Which side would you like (Soda, Beer, or Coca)?.\nNhấn Add.\nCuộn xuống Confirmation. Trong confirmation prompt, tôi sẽ viết Nice! Would you like me to order your {Drink_types}?.\n{Drink_types} sẽ là giá trị mà người dùng chọn từ Slots.\nTrong trường hợp người dùng trả lời No, tôi sẽ thiết lập Decline response để bot trả lời là Bummer! Stay hungry, my friend.\nCuộn xuống Fulfillment. Tôi sẽ thông báo cho người dùng trạng thái khi hoàn thành tại On successful fulfillment là Okay, your order is on its way. Would you like to order another fried chicken, a side, or a drink?.\nIn case of failure sẽ là Oh no! Something went wrong. Please try again.\nNhấn Save intent và Build.\nSau khi build, nhấn Test và nhập các tin nhắn để kiểm tra như bên dưới.\n"
},
{
	"uri": "http://Khoadora.github.io/vi/",
	"title": "Amazon Lex Workshops",
	"tags": [],
	"description": "",
	"content": "Amazon Lex Workshops Tổng quan Amazon Lex là một dịch vụ của AWS cho phép bạn tạo các giao diện hội thoại thông minh sử dụng giọng nói và văn bản. Với Amazon Lex, bạn có thể dễ dàng xây dựng các bot hội thoại, ứng dụng dịch vụ khách hàng, hoặc chatbot tự động để tương tác với người dùng một cách tự nhiên.\nCác thành phần của bot Amazon Lex: Intents - đây là một hành động mà người dùng muốn thực hiện. Nó giúp bot hiểu và phân loại nhiệm vụ mà người dùng muốn hoàn thành. Một bot có thể chứa nhiều intent khác nhau, cho phép bot xử lý các yêu cầu khác nhau nhưng có liên quan của người dùng.\nUtterances - đây là các cách diễn đạt bằng văn bản mà người dùng phải gõ hoặc nói để kích hoạt một intent. Một intent có thể chứa nhiều utterance khác nhau, cho phép người dùng kích hoạt bot bằng các cụm từ khác nhau, có thể cung cấp nhiều tham số dữ liệu khác nhau (hoặc \u0026ldquo;slots\u0026rdquo;) qua câu nói của họ.\nPrompts - Amazon Lex có thể định nghĩa các prompt khác nhau cho các giai đoạn khác nhau của cuộc hội thoại, chẳng hạn như khi yêu cầu số tài khoản ngân hàng hoặc ngày đặt vé máy bay. Chúng cũng có thể được ghi đè tại thời điểm chạy bằng các hàm Lambda của bạn.\nSlots - đây là các mục dữ liệu mà intent của bot cần để hoàn thành nhiệm vụ của nó; ví dụ, cho intent đặt vé máy bay, bạn có thể cần các slot cho sân bay đi, sân bay đến, ngày bay, giờ bay và hạng vé. Amazon Lex có nhiều loại slot có sẵn, nhưng bạn có thể tự tạo các loại slot tùy chỉnh cho trường hợp sử dụng của mình.\nFulfilment - đây là trạng thái cuối cùng của intent, thường đi kèm với một thông báo kết thúc và một số thông tin bổ sung cho người dùng; ví dụ, khi đặt vé máy bay, bạn có thể xác nhận rằng vé đã được đặt và cung cấp tóm tắt về lộ trình cùng với số hiệu chuyến bay mà người dùng đã đặt.\nAmazon Lex hoạt động như thế nào? Amazon Lex giúp xây dựng các giao diện hội thoại tích hợp với các ứng dụng giọng nói và văn bản. Quy trình bắt đầu bằng việc xác định vấn đề cần giải quyết và kết quả mong muốn. Sau đó, chatbot nhận một yêu cầu (Intent), lấy dữ liệu từ người dùng (Utterance), yêu cầu thêm thông tin (Prompt), thu thập dữ liệu cần thiết (Slot), và cuối cùng thực hiện một hành động để hoàn tất yêu cầu (Fulfillment). Khi hoàn tất, chatbot được kiểm thử và triển khai vào môi trường sản xuất.\nMục tiêu của Workshop: Sau khi hoàn thành workshop này, bạn sẽ học được cách tạo một chatbot với nhiều intent và các hàm Lambda handler, thêm các thẻ phản hồi (response tags). Bạn cũng có thể tạo một trang web độc lập cho bot Amazon Lex hiện có của mình hoặc nhúng nó vào trang web hiện có. Ngoài ra, bạn cũng có thể ứng dụng chatbot vào ứng dụng Slack để hỗ trợ giao tiếp và làm việc.\nNội dung: Giới thiệu Tạo ChatBot để đặt Gà Rán Xác thực dữ liệu Slot với Lambda Tích hợp ChatBot vào một Trang Web Thêm các Thẻ Phản hồi Tích hợp với Slack Dọn dẹp Tài liệu tham khảo: Amazon Lex (ChatBot) của Cumulus Cycles, truy cập ngày 01/09/2024. Amazon Lex Workshop của AWS, truy cập ngày 02/09/2024. Amazon Lex của Wikipedia, truy cập ngày 02/09/2024. Tạo tài khoản AWS, truy cập ngày 20/09/2024. "
},
{
	"uri": "http://Khoadora.github.io/vi/2-build-a-chatbot/2.2-create-intent-and-slot-types/2.2.8.-configure-intent-fallbackintent/",
	"title": "Cấu hình intent FallbackIntent",
	"tags": [],
	"description": "",
	"content": " Chọn intent FallbackIntent.\nCuộn xuống Closing response. Thêm vào tin nhắn là Sorry, I can't assist with that.\nSave intent và build, chúng ta có thể thấy sự khác biệt trong hình.\n"
},
{
	"uri": "http://Khoadora.github.io/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://Khoadora.github.io/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]